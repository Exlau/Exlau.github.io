<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS备忘</title>
    <url>/2020/11/04/CSS%E5%A4%87%E5%BF%98(building)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CSS备忘（building）"><a href="#CSS备忘（building）" class="headerlink" title="CSS备忘（building）"></a>CSS备忘（building）</h1><h2 id="属性相关"><a href="#属性相关" class="headerlink" title="属性相关"></a>属性相关</h2><ul>
<li><p>border-bottom：仅下边框</p>
</li>
<li><p>text-decoration：文字修饰</p>
</li>
<li><p>all：将选择器选中的部分设置为同一个样式(一般只能是共有的 inherit unset等)</p>
</li>
<li><p><code>background</code>相关</p>
<ul>
<li><code>background-size</code>:<ul>
<li><code>cover</code> —浏览器将使图像足够大，使它完全覆盖了盒子区，同时仍然保持其高宽比。在这种情况下，有些图像可能会跳出盒子外</li>
<li><code>contain</code> — 浏览器将使图像的大小适合盒子内。在这种情况下，如果图像的长宽比与盒子的长宽比不同，则可能在图像的任何一边或顶部和底部出现间隙。</li>
</ul>
</li>
<li><code>background-positon</code>：(根据坐标调整，默认(0,0)为左上角)<ul>
<li>设置规则为：先x轴后y轴</li>
</ul>
</li>
<li><code>background-attachment</code>：<ul>
<li><code>scroll</code>：使背景随页面滚动而滚动</li>
<li><code>fixed</code>：固定</li>
<li><code>local</code>：</li>
</ul>
</li>
</ul>
</li>
<li><p><code>inline-size</code>：可自动根据书写模式调整内联文本宽度</p>
</li>
<li><p><code>overflow</code>:（当溢出盒子时应怎样处理溢出的文本）</p>
<ul>
<li><code>visible</code>：默认属性，可视</li>
<li><code>hidden</code></li>
<li><code>scroll</code>：添加滚动条，可与-x,-y配合使用</li>
</ul>
</li>
<li><p><code>opacity</code>:透明度</p>
</li>
<li><p>min-，max-属性：（设置最值）</p>
<p>例如</p>
<ul>
<li><code>min-height</code>：最小高度</li>
</ul>
</li>
<li><p><code>object-fit</code>：（调整图像覆盖方式）</p>
<ul>
<li><code>cover</code>：比例不变，覆盖盒子</li>
<li><code>contain</code>：比例不变，适应盒子</li>
<li><code>fill</code>：比例变，覆盖盒子</li>
</ul>
</li>
</ul>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><table>
<thead>
<tr>
<th align="left">Property</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-font-font.html">font</a></td>
<td align="left">在一个声明中设置所有的字体属性</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-font-font-family.html">font-family</a></td>
<td align="left">指定文本的字体系列</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-font-font-size.html">font-size</a></td>
<td align="left">指定文本的字体大小</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-font-font-style.html">font-style</a></td>
<td align="left">指定文本的字体样式</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-font-font-variant.html">font-variant</a></td>
<td align="left">以小型大写字体或者正常字体显示文本。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-font-weight.html">font-weight</a></td>
<td align="left">指定字体的粗细。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul>
<li><code>a:link</code> - 正常，未访问过的链接</li>
<li><code>a:visited</code> - 用户已访问过的链接</li>
<li><code>a:hover</code> - 当用户鼠标放在链接上时</li>
<li><code>a:active</code> - 链接被点击的那一刻</li>
</ul>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul>
<li><code>list-style-type</code>：改变列表前的圆点<ul>
<li>可添加图片<code>list-style-type: url()</code></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-list-style.html">list-style</a></td>
<td align="left">简写属性。用于把所有用于列表的属性设置于一个声明中</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-list-style-image.html">list-style-image</a></td>
<td align="left">将图像设置为列表项标志。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-list-style-position.html">list-style-position</a></td>
<td align="left">设置列表中列表项标志的位置。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-list-style-type.html">list-style-type</a></td>
<td align="left">设置列表项标志的类型。</td>
</tr>
</tbody></table>
<h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-border.html">border</a></td>
<td align="left">简写属性，用于把针对四个边的属性设置在一个声明。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-border-style.html">border-style</a></td>
<td align="left">用于设置元素所有边框的样式，或者单独地为各边设置边框样式。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-border-width.html">border-width</a></td>
<td align="left">简写属性，用于为元素的所有边框设置宽度，或者单独地为各边边框设置宽度。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-border-color.html">border-color</a></td>
<td align="left">简写属性，设置元素的所有边框中可见部分的颜色，或为 4 个边分别设置颜色。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-border-bottom.html">border-bottom</a></td>
<td align="left">简写属性，用于把下边框的所有属性设置到一个声明中。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-border-bottom-color.html">border-bottom-color</a></td>
<td align="left">设置元素的下边框的颜色。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-border-bottom-style.html">border-bottom-style</a></td>
<td align="left">设置元素的下边框的样式。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-border-bottom-width.html">border-bottom-width</a></td>
<td align="left">设置元素的下边框的宽度。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-border-left.html">border-left</a></td>
<td align="left">简写属性，用于把左边框的所有属性设置到一个声明中。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-border-left-color.html">border-left-color</a></td>
<td align="left">设置元素的左边框的颜色。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-border-left-style.html">border-left-style</a></td>
<td align="left">设置元素的左边框的样式。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-border-left-width.html">border-left-width</a></td>
<td align="left">设置元素的左边框的宽度。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-border-right.html">border-right</a></td>
<td align="left">简写属性，用于把右边框的所有属性设置到一个声明中。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-border-right-color.html">border-right-color</a></td>
<td align="left">设置元素的右边框的颜色。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-border-right-style.html">border-right-style</a></td>
<td align="left">设置元素的右边框的样式。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-border-right-width.html">border-right-width</a></td>
<td align="left">设置元素的右边框的宽度。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-border-top.html">border-top</a></td>
<td align="left">简写属性，用于把上边框的所有属性设置到一个声明中。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-border-top-color.html">border-top-color</a></td>
<td align="left">设置元素的上边框的颜色。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-border-top-style.html">border-top-style</a></td>
<td align="left">设置元素的上边框的样式。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cssref/pr-border-top-width.html">border-top-width</a></td>
<td align="left">设置元素的上边框的宽度。</td>
</tr>
</tbody></table>
<h3 id="轮廓-outline"><a href="#轮廓-outline" class="headerlink" title="轮廓:outline"></a>轮廓:outline</h3><p><strong>outline</strong>包围在<strong>border</strong>旁边</p>
<p><code>outline: outline-color, outline-style, outline-width</code></p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>outline-color</em></td>
<td align="left">规定边框的颜色。</td>
</tr>
<tr>
<td align="left"><em>outline-style</em></td>
<td align="left">规定边框的样式。</td>
</tr>
<tr>
<td align="left"><em>outline-width</em></td>
<td align="left">规定边框的宽度。</td>
</tr>
<tr>
<td align="left">inherit</td>
<td align="left">规定应该从父元素继承 outline 属性的设置。</td>
</tr>
</tbody></table>
<h3 id="隐藏与显示"><a href="#隐藏与显示" class="headerlink" title="隐藏与显示"></a>隐藏与显示</h3><ul>
<li><code>display:none</code>：占位和本体都消失</li>
<li><code>visibility:hidden</code>：仅本体消失，占位还在</li>
</ul>
<h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><ul>
<li><code>display:inline</code>：将元素设置为内联元素<ul>
<li>不能修改width、height属性，大小由内容撑开</li>
<li>padding属性 top、right、bottom、left设置都有效；margin属性只有left、right设置有效</li>
</ul>
</li>
<li><code>display:block</code>：将元素设置为块级元素</li>
<li><code>display:inline-block</code>：元素设置为行内块级元素<ul>
<li>共享行</li>
<li>可修改width height</li>
</ul>
</li>
</ul>
<h3 id="Position"><a href="#Position" class="headerlink" title="Position"></a>Position</h3><ul>
<li><p><code>static</code>：遵循浏览器本身的规则</p>
</li>
<li><p><code>fixed</code>：固定定位，即使滚动窗口也不动</p>
</li>
<li><p><code>relative</code>：相对定位，相对其<code>static</code>的位置。在定义<code>position:relative</code>后进行位置移动会在其<code>static</code>位置的基础上移动</p>
</li>
<li><p><code>absolute</code>：相对于最近已定位父元素，如果没有， 则相对于<code>&lt;html&gt;</code>元素</p>
</li>
<li><p><code>sticky</code>：粘性定位的元素是依赖于用户的滚动，在 <code>position:relative</code> 与 <code>position:fixed</code> 定位之间切换。</p>
<p>它的行为就像 <code>position:relative</code>页面滚动超出目标区域时，它的表现就像 <code>position:fixed</code>，它会固定在目标位置。</p>
<p>超过某个阈值会变为<code>fixed</code></p>
</li>
</ul>
<h3 id="重叠处理"><a href="#重叠处理" class="headerlink" title="重叠处理"></a>重叠处理</h3><ul>
<li><code>z-index：</code>赋一个数值，越大在z轴方向堆叠越高</li>
</ul>
<h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><ul>
<li><code>clear</code>：属性指定元素两侧不能出现浮动元素，避免元素混乱<ul>
<li>both</li>
</ul>
</li>
</ul>
<h3 id="supports"><a href="#supports" class="headerlink" title="@supports"></a>@supports</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 只会在浏览器支持supports（）内的内容时才应用样式*/</span></span><br><span class="line"><span class="keyword">@supports</span>(**)&#123;</span><br><span class="line">	<span class="comment">/*css code */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="继承相关"><a href="#继承相关" class="headerlink" title="继承相关"></a>继承相关</h2><h3 id="不能继承的属性"><a href="#不能继承的属性" class="headerlink" title="不能继承的属性"></a>不能继承的属性</h3><ul>
<li>width</li>
</ul>
<h3 id="控制继承"><a href="#控制继承" class="headerlink" title="控制继承"></a>控制继承</h3><ul>
<li>inherit：强制开启继承</li>
<li>initial：设置为浏览器默认</li>
<li>unset：设置为文档默认</li>
</ul>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">示例</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>[attr]</code></td>
<td align="left"><code>a[title]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素——方括号里的值。</td>
</tr>
<tr>
<td align="left"><code>[attr=value]</code></td>
<td align="left"><code>a[href=&quot;https://example.com&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值正为<em>value</em>——引号中的字符串。</td>
</tr>
<tr>
<td align="left"><code>[attr~=value]</code></td>
<td align="left"><code>p[class~=&quot;special&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素 ，其值正为<em>value</em>，或者匹配带有一个<em>attr</em>属性的元素，其值有一个或者更多，至少有一个和<em>value</em>匹配。（即可以匹配class=”hello special”类似这样的)</td>
</tr>
<tr>
<td align="left">`[attr</td>
<td align="left">=value]`</td>
<td align="left">`div[lang</td>
</tr>
</tbody></table>
<hr>
<table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">示例</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>[attr^=value]</code></td>
<td align="left"><code>li[class^=&quot;box-&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值开头为<em>value</em>子字符串。</td>
</tr>
<tr>
<td align="left"><code>[attr$=value]</code></td>
<td align="left"><code>li[class$=&quot;-box&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值结尾为<em>value</em>子字符串</td>
</tr>
<tr>
<td align="left"><code>[attr*=value]</code></td>
<td align="left"><code>li[class*=&quot;box&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值的字符串中的任何地方，至少出现了一次<em>value</em>子字符串。</td>
</tr>
</tbody></table>
<hr>
<ul>
<li><strong><em>i</em></strong> 标记可让浏览器以大小写不敏感的方式检测选择器    </li>
</ul>
<h2 id="单位制度"><a href="#单位制度" class="headerlink" title="单位制度"></a>单位制度</h2><table>
<thead>
<tr>
<th align="left">单位</th>
<th align="left">名称</th>
<th align="left">等价换算</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>cm</code></td>
<td align="left">厘米</td>
<td align="left">1cm = 96px/2.54</td>
</tr>
<tr>
<td align="left"><code>mm</code></td>
<td align="left">毫米</td>
<td align="left">1mm = 1/10th of 1cm</td>
</tr>
<tr>
<td align="left"><code>Q</code></td>
<td align="left">四分之一毫米</td>
<td align="left">1Q = 1/40th of 1cm</td>
</tr>
<tr>
<td align="left"><code>in</code></td>
<td align="left">英寸</td>
<td align="left">1in = 2.54cm = 96px</td>
</tr>
<tr>
<td align="left"><code>pc</code></td>
<td align="left">十二点活字</td>
<td align="left">1pc = 1/16th of 1in</td>
</tr>
<tr>
<td align="left"><code>pt</code></td>
<td align="left">点</td>
<td align="left">1pt = 1/72th of 1in</td>
</tr>
<tr>
<td align="left"><code>px</code></td>
<td align="left">像素</td>
<td align="left">1px = 1/96th of 1in</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">单位</th>
<th align="left">相对于</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>em</code></td>
<td align="left">在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width</td>
</tr>
<tr>
<td align="left"><code>ex</code></td>
<td align="left">字符“x”的高度</td>
</tr>
<tr>
<td align="left"><code>ch</code></td>
<td align="left">数字“0”的宽度</td>
</tr>
<tr>
<td align="left"><code>rem</code></td>
<td align="left">根元素的字体大小</td>
</tr>
<tr>
<td align="left"><code>lh</code></td>
<td align="left">元素的line-height</td>
</tr>
<tr>
<td align="left"><code>vw</code></td>
<td align="left">视窗宽度的1%</td>
</tr>
<tr>
<td align="left"><code>vh</code></td>
<td align="left">视窗高度的1%</td>
</tr>
<tr>
<td align="left"><code>vmin</code></td>
<td align="left">视窗较小尺寸的1%</td>
</tr>
<tr>
<td align="left"><code>vmax</code></td>
<td align="left">视图大尺寸的1%</td>
</tr>
</tbody></table>
<h2 id="布局相关"><a href="#布局相关" class="headerlink" title="布局相关"></a>布局相关</h2><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><h4 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h4><p><img src="https://github.com/Exlau/-/blob/main/flex%E5%B8%83%E5%B1%80.png?raw=true" alt="flex总览"></p>
<ul>
<li><strong>主轴（main axis）</strong>是沿着 flex 元素放置的方向延伸的轴（比如页面上的横向的行、纵向的列）。该轴的开始和结束被称为 <strong>main start</strong> 和 <strong>main end</strong>。</li>
<li><strong>交叉轴（cross axis）</strong>是垂直于 flex 元素放置方向的轴。该轴的开始和结束被称为 <strong>cross start</strong> 和 <strong>cross end</strong>。</li>
<li>设置了 <code>display: flex</code> 的父元素被称之为 <strong>flex 容器（flex container）。</strong></li>
<li>在 flex 容器中表现为柔性的盒子的元素被称之为 <strong>flex 项</strong>（<strong>flex item</strong>）</li>
</ul>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li><code>flex-direction</code>:（指定主轴方向）<ul>
<li><code>column</code></li>
<li><code>row</code></li>
</ul>
</li>
<li><code>flex-wrap</code>:</li>
<li><code>flex-flow</code>=<code>flex-direction flex-wrap</code></li>
<li><code>flex: num</code>：为每个选项设置相对大小</li>
<li><code>flex-grow</code>：设定多余部分分配比例（无单位）</li>
<li><code>flex-shrink</code>：溢出调整？</li>
<li><code>align-item</code>:  默认的值是 <code>stretch</code>，其会使所有 flex 项沿着交叉轴的方向拉伸以填充父容器。如果父容器在交叉轴方向上没有固定宽度（即高度），则所有 flex 项将变得与最长的 flex 项一样长（即高度保持一致）。<code>center</code> 值会使这些项保持其原有的高度，但是会在交叉轴居中。这就是那些按钮垂直居中的原因。也可以设置诸如 <code>flex-start</code> 或 <code>flex-end</code> 这样使 flex 项在交叉轴的开始或结束处对齐所有的值。</li>
<li><code>justify-content</code>：<ul>
<li><code>flex-start</code>：默认值，从主轴开始处排列</li>
<li><code>flex-end</code>：排列到主轴末尾</li>
<li><code>center</code>：在主轴居中</li>
<li><code>space-around</code>：均匀分布在主轴</li>
<li><code>space-between</code>：效果同space-around但左右无空隙</li>
</ul>
</li>
</ul>
<h4 id="项排序"><a href="#项排序" class="headerlink" title="项排序"></a>项排序</h4><ul>
<li><code>order</code>：默认值为0，值越大排位越靠后</li>
</ul>
<h3 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h3><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><ul>
<li><p><code>grid-template-columns:num1 ...numN</code>：添加N个宽度为num的列</p>
<ul>
<li><code>repeat(N,w)</code>方法：创建N个w宽的列</li>
</ul>
</li>
<li><p><code>grid-(column)-gap</code>：调整格间隙</p>
</li>
<li><p><code>grid-auto-rows</code>：隐式表格的高</p>
<ul>
<li><code>minmax(min,max)</code>方法：设置最小和最大值</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>CSS备忘</tag>
      </tags>
  </entry>
  <entry>
    <title>D3js</title>
    <url>/2020/12/20/D3js/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="D3"><a href="#D3" class="headerlink" title="D3"></a>D3</h1><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>语法与Jquery相同，只是接口不同</p>
<p>例如：</p>
<ul>
<li><strong>d3.select(‘#id’)</strong></li>
<li><strong>d3.selectall(‘.calss’)</strong></li>
</ul>
<h2 id="SVG属性"><a href="#SVG属性" class="headerlink" title="SVG属性"></a>SVG属性</h2><ul>
<li>id class</li>
<li>x,y</li>
<li>fill stroke</li>
<li>height width r</li>
<li>transform -&gt; translate, rotate, scale</li>
</ul>
<h3 id="设置属性-attr"><a href="#设置属性-attr" class="headerlink" title="设置属性.attr"></a>设置属性.attr</h3><p><strong>.attr(‘attribute’,’value’)</strong></p>
<h2 id="添加-删除"><a href="#添加-删除" class="headerlink" title="添加/删除"></a>添加/删除</h2><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p><strong>d3.select(‘#main’).append(‘rect’).attr(‘width’,100).attr(‘height’,100)</strong></p>
<p>​    表示在main下添加一个矩形宽为100 长为100</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h2 id="比例尺"><a href="#比例尺" class="headerlink" title="比例尺"></a>比例尺</h2><h3 id="定义比例尺"><a href="#定义比例尺" class="headerlink" title="定义比例尺"></a>定义比例尺</h3><p><code>d3.scaleLinear().domain([0,10]).range([-1000,1000])</code></p>
<p>这段代码创建了<code>0-10</code>对<code>-1000-1000</code>的映射</p>
]]></content>
  </entry>
  <entry>
    <title>Echarts</title>
    <url>/2020/12/20/Echarts/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>Echarts使用JSON格式进行配置</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置标题</span></span><br><span class="line">title:&#123;</span><br><span class="line">	text:&#x27;&#x27;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//配置提示信息</span></span><br><span class="line">tooltip:&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//图例组件</span></span><br><span class="line">legend:&#123;</span><br><span class="line">    data:[&#123;</span><br><span class="line">        name:&#x27;&#x27;,</span><br><span class="line">        <span class="comment">//图形</span></span><br><span class="line">        icon:&#x27;cirle&#x27;,</span><br><span class="line">        <span class="comment">//文本颜色</span></span><br><span class="line">        textStyle:&#123;</span><br><span class="line">            color:&#x27;red&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//X轴上显示的项</span></span><br><span class="line">xAxis:&#123;</span><br><span class="line">    data:[&#x27;&#x27;,&#x27;&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Y轴上显示的项</span></span><br><span class="line">yAxis:&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//系列列表</span></span><br><span class="line">series:[&#123;</span><br><span class="line">    <span class="comment">//系列名称</span></span><br><span class="line">	name:&#x27;&#x27;,</span><br><span class="line">    <span class="comment">//系列图标类型</span></span><br><span class="line">    type:&#x27;bar&#x27;，</span><br><span class="line">    <span class="comment">//系列中的数据内容</span></span><br><span class="line">    data:[a,s,d,f,g]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<h3 id="常用type集合"><a href="#常用type集合" class="headerlink" title="常用type集合"></a>常用type集合</h3><ul>
<li>**type: ‘bar’**：柱状/条形图</li>
<li>**type: ‘line’**：折线/面积图</li>
<li>**type: ‘pie’**：饼图</li>
<li>**type: ‘scatter’**：散点（气泡）图</li>
<li>**type: ‘effectScatter’**：带有涟漪特效动画的散点（气泡）</li>
<li>**type: ‘radar’**：雷达图</li>
<li>**type: ‘tree’**：树型图</li>
<li>**type: ‘treemap’**：树型图</li>
<li>**type: ‘sunburst’**：旭日图</li>
<li>**type: ‘boxplot’**：箱形图</li>
<li>**type: ‘candlestick’**：K线图</li>
<li>**type: ‘heatmap’**：热力图</li>
<li>**type: ‘map’**：地图</li>
<li>**type: ‘parallel’**：平行坐标系的系列</li>
<li>**type: ‘lines’**：线图</li>
<li>**type: ‘graph’**：关系图</li>
<li>**type: ‘sankey’**：桑基图</li>
<li>**type: ‘funnel’**：漏斗图</li>
<li>**type: ‘gauge’**：仪表盘</li>
<li>**type: ‘pictorialBar’**：象形柱图</li>
<li>**type: ‘themeRiver’**：主题河流</li>
<li>**type: ‘custom’**：自定义系列</li>
</ul>
<h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><h3 id="颜色主题"><a href="#颜色主题" class="headerlink" title="颜色主题"></a>颜色主题</h3><p>默认两个主题</p>
<ul>
<li>light：<code>var chart = echarts.init(dom, &#39;light&#39;);</code></li>
<li>dark:  <code>var chart = echarts.init(dom, &#39;dark&#39;);</code></li>
</ul>
<h3 id="调色盘"><a href="#调色盘" class="headerlink" title="调色盘"></a>调色盘</h3><p>调色盘可以在 option 中设置。</p>
<p>调色盘给定了一组颜色，图形、系列会自动从其中选择颜色。</p>
<p>可以设置全局的调色盘，也可以设置系列自己专属的调色盘。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">    <span class="comment">// 全局调色盘。</span></span><br><span class="line">    color: [&#x27;#c23531&#x27;,&#x27;#2f4554&#x27;, &#x27;#61a0a8&#x27;, &#x27;#d48265&#x27;, &#x27;#91c7ae&#x27;,&#x27;#749f83&#x27;,  &#x27;#ca8622&#x27;, &#x27;#bda29a&#x27;,&#x27;#6e7074&#x27;, &#x27;#546570&#x27;, &#x27;#c4ccd3&#x27;],</span><br><span class="line"></span><br><span class="line">    series: [&#123;</span><br><span class="line">        type: &#x27;bar&#x27;,</span><br><span class="line">        <span class="comment">// 此系列自己的调色盘。</span></span><br><span class="line">        color: [&#x27;#dd6b66&#x27;,&#x27;#759aa0&#x27;,&#x27;#e69d87&#x27;,&#x27;#8dc1a9&#x27;,&#x27;#ea7e53&#x27;,&#x27;#eedd78&#x27;,&#x27;#73a373&#x27;,&#x27;#73b9bc&#x27;,&#x27;#7289ab&#x27;, &#x27;#91ca8c&#x27;,&#x27;#f49f42&#x27;],</span><br><span class="line">        ...</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        type: &#x27;pie&#x27;,</span><br><span class="line">        <span class="comment">// 此系列自己的调色盘。</span></span><br><span class="line">        color: [&#x27;#37A2DA&#x27;, &#x27;#32C5E9&#x27;, &#x27;#67E0E3&#x27;, &#x27;#9FE6B8&#x27;, &#x27;#FFDB5C&#x27;,&#x27;#ff9f7f&#x27;, &#x27;#fb7293&#x27;, &#x27;#E062AE&#x27;, &#x27;#E690D1&#x27;, &#x27;#e7bcf3&#x27;, &#x27;#9d96f5&#x27;, &#x27;#8378EA&#x27;, &#x27;#96BFFF&#x27;],</span><br><span class="line">        ...</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高亮-emphasis"><a href="#高亮-emphasis" class="headerlink" title="高亮-emphasis"></a>高亮-emphasis</h3><p>在鼠标悬浮到图形元素上时，一般会出现高亮的样式。默认情况下，高亮的样式是根据普通样式自动生成的。</p>
<p>如果要自定义高亮样式可以通过 emphasis 属性来定制：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">emphasis: &#123;</span><br><span class="line">    itemStyle: &#123;</span><br><span class="line">        <span class="comment">// 高亮时点的颜色</span></span><br><span class="line">        color: &#x27;red&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    label: &#123;</span><br><span class="line">        show: true,</span><br><span class="line">        <span class="comment">// 高亮时标签的文字</span></span><br><span class="line">        formatter: &#x27;高亮时显示的标签内容&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="异步加载添加loading效果"><a href="#异步加载添加loading效果" class="headerlink" title="异步加载添加loading效果"></a>异步加载添加loading效果</h2><p>只需要调用 showLoading 方法显示。数据加载完成后再调用 hideLoading 方法隐藏加载动画：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">var myChart = echarts.init(document.getElementById(&#x27;main&#x27;));</span><br><span class="line">myChart.showLoading();  // 开启 loading 效果</span><br><span class="line">$.get(&#x27;https://www.runoob.com/static/js/echarts_test_data.json&#x27;, function (data) &#123;</span><br><span class="line">    myChart.hideLoading();  // 隐藏 loading 效果</span><br><span class="line">    myChart.setOption(&#123;</span><br><span class="line">        series : [</span><br><span class="line">            &#123;</span><br><span class="line">                name: &#x27;访问来源&#x27;,</span><br><span class="line">                type: &#x27;pie&#x27;,    // 设置图表类型为饼图</span><br><span class="line">                radius: &#x27;55%&#x27;,  // 饼图的半径，外半径为可视区尺寸（容器高宽中较小一项）的 55% 长度。</span><br><span class="line">                data:data.data_pie</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, &#x27;json&#x27;)</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/ringwang/p/9619472.html">https://www.cnblogs.com/ringwang/p/9619472.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>JS备忘</title>
    <url>/2020/10/21/JS%E5%A4%87%E5%BF%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h1><h2 id="一般事件绑定"><a href="#一般事件绑定" class="headerlink" title="一般事件绑定"></a>一般事件绑定</h2><ul>
<li><p><code>.onclick</code>：点击事件</p>
</li>
<li><p><code>.onfocus</code>：聚焦（选中）</p>
</li>
<li><p><code>.onblur</code>：解除聚焦</p>
</li>
<li><p><code>.onmouse(over/out)</code>：鼠标移入/移开</p>
</li>
<li><p><code>.onsubmit</code>：表单提交</p>
</li>
<li><p><code>.addEventListener(&#39;事件&#39;,函数)/removeEventListener(&#39;事件&#39;,函数)</code>：添加/移除，监听事件，可对一个对象的一个事件添加两个不同函数</p>
</li>
</ul>
<h2 id="特殊对象"><a href="#特殊对象" class="headerlink" title="特殊对象"></a>特殊对象</h2><ul>
<li>诸如<code>event evt e（可以是任何表示）</code>都是事件对象会默认传入事件绑定的函数，<code>event/evt/e.target</code>指刚刚发生事件的元素</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li><p><code>Objet().</code>的属性不被继承，而<code>Object.prototype.</code>的属性被继承</p>
</li>
<li><p><code>.call()</code>：这个函数允许您调用一个在这个文件里别处定义的函数。第一个参数指明了在您运行这个函数时想对“<code>this</code>”指定的值，也就是说，您可以重新指定您调用的函数里所有“<code>this</code>”指向的对象。可以让构造器继承某个构造器的属性</p>
</li>
<li><p><code>newObj.prototype = Object.create(Obj.prototype)</code>这串代码使得newObj继承了Obj的方法</p>
</li>
<li><p><code>newObj.prototype.constructor = newObj</code>这使得newObj的prototype和constructior只想的newObj构造器本身，而不是调用call函数的对象的构造器</p>
</li>
<li><p><code>Obj.prototype.constructor===Obj()（构造方法）</code></p>
</li>
</ul>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p><strong>纯数据，无函数</strong></p>
<ul>
<li>获取内部成员的方法类似对象</li>
<li><code>.parse()</code>：接收json字符串，返回json对象</li>
<li><code>.stringify()</code>：接收对象，返回json字符串</li>
</ul>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>JS一般是单线程</p>
<p><code>() =&gt; x</code> 是 <code>()=&gt; &#123;return x;&#125;</code> 的有效简写; </p>
<h3 id="callbacks-回调函数"><a href="#callbacks-回调函数" class="headerlink" title="callbacks(回调函数)"></a>callbacks(回调函数)</h3><p>将回调函数作为参数传递给另一个函数仅仅是把回调函数定义作为参数传递过去 — 回调函数并没有立刻执行，回调函数会在包含它的函数的某个地方异步执行，包含函数负责在合适的时候执行回调函数。</p>
<h3 id="promises"><a href="#promises" class="headerlink" title="promises"></a>promises</h3><p>用来表示异步操作成功或者失败的对象</p>
<p>​    有三个状态：</p>
<ul>
<li><p>pending(待定)</p>
</li>
<li><p>resolved(已解决)</p>
<ul>
<li>fullfilled（成功）</li>
<li>rejected（失败）</li>
</ul>
</li>
</ul>
<p><code>promise.all()</code>：传入promise数组，当数组中所有promise执行成功后再执行<code>promise.all()</code>的<code>then</code></p>
<h3 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h3><h4 id="setTimeout-和setInterval"><a href="#setTimeout-和setInterval" class="headerlink" title="setTimeout()和setInterval()"></a>setTimeout()和setInterval()</h4><ul>
<li><p><code>setTimeout(func,time)</code>：在一段时间time后执行函数func</p>
<ul>
<li><code>clearTimeout()</code>：清除</li>
</ul>
</li>
<li><p><code>setInterval(func,time)</code>：以固定时间间隔重复运行代码</p>
<ul>
<li><p><code>clearInterval()</code>：清除intervals</p>
</li>
<li><pre><code class="javascript">setTimeout(func,time)
function func()&#123;
    //options-codes;
    setTimeout(func,time);
&#125;
//用递归和setTimeout()实现与setInterval相同的功能</code></pre>
</li>
</ul>
</li>
<li><p><code>setTimeout()</code>严格按照所传入的时间间隔执行，而<code>setInterval()</code>传入的时间间隔则包括代码执行时间和间隔时间(<em>例如传入100ms，代码执行10ms，则实际间隔只有90ms</em>)</p>
</li>
<li><p>使用<strong>0</strong>用作<code>setTimeout()</code>的回调函数会立刻执行，但是在主线程代码运行之后执行。</p>
</li>
</ul>
<h4 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame()"></a>requestAnimationFrame()</h4><ul>
<li><code>requestAnimationFrame()</code>：setInterval()的现代版本;在浏览器下一次重新绘制显示之前执行指定的代码块，从而允许动画在适当的帧率下运行，而不管它在什么环境中运行.</li>
<li><code>requestAnimationFrame()</code>:可传入一个带时间戳参数的函数，表示从函数执行到现在的时间</li>
<li><code>cancelAnimationFrame()</code>：用于撤销动画</li>
</ul>
<h3 id="异步API"><a href="#异步API" class="headerlink" title="异步API"></a>异步API</h3><ul>
<li><code>URL.createObjectURL(thing)</code>：此静态方法会创建一个thing的URL</li>
</ul>
<p><strong>fetch</strong></p>
<ul>
<li>全局fetch：<code>fetch(URL).then(func1()).then(func2()).catch(func3(err))</code>：返回一个promise，两个<code>then</code>的参数都是回调函数，如果前一个操作成功则运行该回调函数，并且每个回调函数的参数均是前一个操作的返回值，每个<code>then</code>也会返回一个promise，当任何一个<code>then</code>失败就会运行<code>catch</code></li>
</ul>
<h2 id="APIS"><a href="#APIS" class="headerlink" title="APIS"></a>APIS</h2><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><ul>
<li>window是载入浏览器的标签，在JavaScript中用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window"><code>Window</code></a>对象来表示，使用这个对象的可用方法，你可以返回窗口的大小（参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/innerWidth"><code>Window.innerWidth</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/innerHeight"><code>Window.innerHeight</code></a>），操作载入窗口的文档，存储客户端上文档的特殊数据（例如使用本地数据库或其他存储设备），为当前窗口绑定<a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#A_series_of_fortunate_events">event handler</a>，等等。</li>
<li>navigator表示浏览器存在于web上的状态和标识（即用户代理）。在JavaScript中，用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator"><code>Navigator</code></a>来表示。你可以用这个对象获取一些信息，比如来自用户摄像头的地理信息、用户偏爱的语言、多媒体流等等。</li>
<li>document（在浏览器中用DOM表示）是载入窗口的实际页面，在JavaScript中用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document"><code>Document</code></a> 对象表示，你可以用这个对象来返回和操作文档中HTML和CSS上的信息。例如获取DOM中一个元素的引用，修改其文本内容，并应用新的样式，创建新的元素并添加为当前元素的子元素，甚至把他们一起删除。<ul>
<li><code>.querySelector()</code>：根据dom规则寻找元素</li>
<li><code>.appendChild()</code>：添加子元素</li>
<li><code>.removeChild()</code>：rm子元素</li>
</ul>
</li>
</ul>
<h2 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h2><ul>
<li><code>\d</code>：匹配数字</li>
<li><code>\w</code>：匹配字母</li>
<li><code>.</code>：匹配任意字符</li>
<li><code>*</code>：匹配任意个字符，包括<strong>0</strong>个，<ul>
<li>用**+**来表示至少包含一个字符，</li>
<li><strong>？</strong>来匹配0或者1个字符，</li>
<li>{n}表示n个字符</li>
<li>{n,m}表示n-m个字符</li>
</ul>
</li>
<li><code>\s</code>：匹配空白符</li>
<li><code>[]</code>：表示范围，例如<code>[0-9a-zA-Z\_]</code>可以匹配一个数字、字母或者下划线</li>
<li><code>A|B</code>：匹配A或者B</li>
<li><code>^</code>：表示行的开头<ul>
<li><code>^\d</code>：表示以数字开头</li>
</ul>
</li>
<li><code>$</code>：表示行结束<ul>
<li><code>\d$</code>：表示以数字结束</li>
</ul>
</li>
</ul>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2>]]></content>
  </entry>
  <entry>
    <title>HTML备忘</title>
    <url>/2020/10/14/HTML%E5%A4%87%E5%BF%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="HTML备忘录"><a href="#HTML备忘录" class="headerlink" title="HTML备忘录"></a>HTML备忘录</h1><h2 id="标签相关"><a href="#标签相关" class="headerlink" title="标签相关"></a>标签相关</h2><ul>
<li><p>块级元素自动换行而内联元素不自动换行</p>
</li>
<li><p>disabled = <em>value</em> 无论<em>value</em>值为什么，标签都会处于disabled状态，想要改变需将<em>value</em>置空</p>
</li>
<li><p>特殊字符引用表</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">原义字符</th>
<th align="left">等价字符引用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&lt;”</td>
<td align="left">&amp;lt</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">&amp;gt</td>
</tr>
<tr>
<td align="left">“</td>
<td align="left">&amp;quot</td>
</tr>
<tr>
<td align="left">‘</td>
<td align="left">&amp;apos</td>
</tr>
<tr>
<td align="left">&amp;</td>
<td align="left">&amp;amp</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<ul>
<li><p>使用相对路径优于绝对路径(舍去了DNS查找等操作)</p>
</li>
<li><p><code>&lt;script&gt;</code>放在<code> &lt;body&gt;</code>末尾前更优，这样可以确保脚本加载前浏览器已经解析HTML内容</p>
</li>
<li><p><code> &lt;a&gt;</code>标签的title属性作为悬停提示</p>
</li>
<li><p>href的mailto subject cc body等关键字，用于发送邮件</p>
</li>
<li><p>描述列表</p>
</li>
<li><p>块引用<code> &lt;blockquote cite=&quot;url&quot;&gt;&lt;/blockquote&gt;</code></p>
</li>
<li><p>行内引用<code>&lt;q cite=&quot;url&quot;&gt;</code></p>
</li>
<li><p>缩略语<code>&lt;abbr title=&quot;..&quot;&gt;&lt;/abbr&gt;</code></p>
</li>
<li><p>保留空格渲染<code>&lt;pre&gt;content&lt;/pre&gt;</code></p>
</li>
<li><p>标记键盘输入<code>&lt;kbd&gt;&lt;/kbd&gt;</code></p>
</li>
<li><p>换行<code>&lt;br&gt;</code></p>
</li>
<li><p>水平线<code>&lt;hr&gt;</code></p>
</li>
<li><p>嵌入其他网页<code>&lt;iframe&gt;</code></p>
<p>属性：</p>
<p>allowfullscreen：可设置全屏</p>
<p>frameborder：边框</p>
<p>（尽量用js设置src）</p>
</li>
<li><p>嵌入PDF,SVG,Flash—<code>&lt;embed&gt;&lt;object&gt;</code></p>
</li>
<li><p>视频标签:<code>&lt;video&gt;</code></p>
<p>属性：</p>
<p>autoplay:自动播放</p>
<p>loop:循环</p>
<p>muted:静音播放</p>
<p>poster:封面图</p>
<p>preload:缓冲（”none”：不缓冲 “auto”：页面加载自动缓冲）</p>
</li>
<li><p>权限管理 sandbox属性</p>
</li>
<li><p>表格相关</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- colgroup 必须包含在table标签内--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">colgroup</span>&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">col</span> <span class="attr">style</span>=<span class="string">&quot;#&quot;</span> <span class="attr">span</span>=<span class="string">&quot;x&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">colgroup</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- col标签可以指定每一行的属性，span是需要设置属性的行数--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- table row --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- table data --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
</li>
</ul>
<h2 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h2><ul>
<li><p>```<img>``的 srcset和sizes属性</p>
<p>举例:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--srcset是一个文件列表，后面以w为单位的数据是文件的像素大小--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">srcset</span>=<span class="string">&quot;elva-fairy-320w.jpg 320w,</span></span></span><br><span class="line"><span class="tag"><span class="string">             elva-fairy-480w.jpg 480w,</span></span></span><br><span class="line"><span class="tag"><span class="string">             elva-fairy-800w.jpg 800w&quot;</span></span></span><br><span class="line">     &lt;!-- sizes 括号内的是条件 括号外的是前面条件为真时采用的样式--&gt;</span><br><span class="line">     sizes=&quot;(max-width: 320px) 280px,</span><br><span class="line">            (max-width: 480px) 440px,</span><br><span class="line">            800px&quot; <span class="comment">&lt;!--无条件的是默认样式--&gt;</span></span><br><span class="line">     src=&quot;elva-fairy-800w.jpg&quot; alt=&quot;Elva dressed as a fairy&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;picture&gt;</code>的应用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">​	&#96;&#96;&#96;&lt;soucre&gt;&#96;&#96;&#96;包含media srcset sizes属性</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;html</span><br><span class="line">&lt;source media&#x3D;&quot;(maxwidth:799px)&quot;srcset&#x3D;&quot;exa.jpg&quot;&gt;</span><br><span class="line">&lt;!--media属性设置一个条件，为真则显示此图片--&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>aaa</p>
]]></content>
      <tags>
        <tag>HTML备忘</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP</title>
    <url>/2020/11/08/HTTP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><p>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
</li>
<li><p>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</p>
</li>
<li><p>HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="客户端请求"><a href="#客户端请求" class="headerlink" title="客户端请求"></a>客户端请求</h3><ul>
<li>请求行</li>
<li>请求头</li>
<li>空行</li>
<li>请求数据</li>
<li><img src="https://raw.githubusercontent.com/Exlau/imageRep/main/2012072810301161.png?token=ANSYLXZ2FUSDNIU6XG23TF27U56W6" alt="结构图"></li>
</ul>
<h3 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h3><p>客户端发出请求后，服务器会先返回一个HTTP状态码<strong>HTTP Status Code</strong></p>
<h4 id="Status-Code"><a href="#Status-Code" class="headerlink" title="Status Code"></a>Status Code</h4><ul>
<li><p>200 - 请求成功</p>
</li>
<li><p>301 - 资源（网页等）被永久转移到其它URL</p>
</li>
<li><p>404 - 请求的资源（网页等）不存在</p>
</li>
<li><p>500 - 内部服务器错误</p>
</li>
<li><p>类别：</p>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">分类描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1**</td>
<td align="left">信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td align="left">2**</td>
<td align="left">成功，操作被成功接收并处理</td>
</tr>
<tr>
<td align="left">3**</td>
<td align="left">重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td align="left">4**</td>
<td align="left">客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td align="left">5**</td>
<td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h4><ul>
<li><p>状态行</p>
</li>
<li><p>消息报头</p>
<ul>
<li><table>
<thead>
<tr>
<th align="left">应答头</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Allow</td>
<td align="left">服务器支持哪些请求方法（如GET、POST等）。</td>
</tr>
<tr>
<td align="left">Content-Encoding</td>
<td align="left">文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</td>
</tr>
<tr>
<td align="left">Content-Length</td>
<td align="left">表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</td>
</tr>
<tr>
<td align="left">Content-Type</td>
<td align="left">表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</td>
</tr>
<tr>
<td align="left">Expires</td>
<td align="left">应该在什么时候认为文档已经过期，从而不再缓存它？</td>
</tr>
<tr>
<td align="left">Last-Modified</td>
<td align="left">文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</td>
</tr>
<tr>
<td align="left">Location</td>
<td align="left">表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</td>
</tr>
<tr>
<td align="left">Refresh</td>
<td align="left">表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<a href="http://host/path&quot;)%E8%AE%A9%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9A%E7%9A%84%E9%A1%B5%E9%9D%A2%E3%80%82">http://host/path&quot;)让浏览器读取指定的页面。</a> 注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=<a href="http://host/path&quot;%EF%BC%9E%E5%AE%9E%E7%8E%B0%EF%BC%8C%E8%BF%99%E6%98%AF%E5%9B%A0%E4%B8%BA%EF%BC%8C%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E6%88%96%E9%87%8D%E5%AE%9A%E5%90%91%E5%AF%B9%E4%BA%8E%E9%82%A3%E4%BA%9B%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8CGI%E6%88%96Servlet%E7%9A%84HTML%E7%BC%96%E5%86%99%E8%80%85%E5%8D%81%E5%88%86%E9%87%8D%E8%A6%81%E3%80%82%E4%BD%86%E6%98%AF%EF%BC%8C%E5%AF%B9%E4%BA%8EServlet%E6%9D%A5%E8%AF%B4%EF%BC%8C%E7%9B%B4%E6%8E%A5%E8%AE%BE%E7%BD%AERefresh%E5%A4%B4%E6%9B%B4%E5%8A%A0%E6%96%B9%E4%BE%BF%E3%80%82">http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。</a>  注意Refresh的意义是”N秒之后刷新本页面或访问指定页面”，而不是”每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=”Refresh” …＞。  注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</td>
</tr>
<tr>
<td align="left">Server</td>
<td align="left">服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</td>
</tr>
<tr>
<td align="left">Set-Cookie</td>
<td align="left">设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</td>
</tr>
<tr>
<td align="left">WWW-Authenticate</td>
<td align="left">客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。 注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>空行</p>
</li>
<li><p>响应正文</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Exlau/imageRep/main/httpmessage.jpg?token=ANSYLX6MVVRDRH66CH7EMQC7U6A4E" alt="结构"></p>
<h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">GET</td>
<td align="left">请求指定的页面信息，并返回实体主体。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">HEAD</td>
<td align="left">类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">POST</td>
<td align="left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">PUT</td>
<td align="left">从客户端向服务器传送的数据取代指定的文档的内容。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">DELETE</td>
<td align="left">请求服务器删除指定的页面。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">CONNECT</td>
<td align="left">HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">OPTIONS</td>
<td align="left">允许客户端查看服务器的性能。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">TRACE</td>
<td align="left">回显服务器收到的请求，主要用于测试或诊断。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">PATCH</td>
<td align="left">是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>整理自菜鸟教程</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs学习</title>
    <url>/2020/12/27/NodeJs%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Node-JS"><a href="#Node-JS" class="headerlink" title="Node.JS"></a>Node.JS</h1><p>Node.JS是使用javascript来开发后端的工具。</p>
<p>可以使得JS代码不再依托浏览器运行。</p>
<p>（注：Node.js也可称为Node，NodeJS）</p>
<h2 id="第一个Node程序"><a href="#第一个Node程序" class="headerlink" title="第一个Node程序"></a>第一个Node程序</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.js</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;hello world!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;终端</span><br><span class="line">&#x2F;&#x2F;运行test.js</span><br><span class="line">node test.js</span><br></pre></td></tr></table></figure>

<p>在终端可输入<code>node</code>进入Node交互模式，交互模式下可输入JS代码直接运行，并且node会将代码结果自行打印出来</p>
<h3 id="使用严格模式"><a href="#使用严格模式" class="headerlink" title="使用严格模式"></a>使用严格模式</h3><p>如果在JavaScript文件开头写上<code>&#39;use strict&#39;;</code>，那么Node在执行该JavaScript时将使用严格模式。但是，在服务器环境下，如果有很多JavaScript文件，每个文件都写上<code>&#39;use strict&#39;;</code>很麻烦。我们可以给Nodejs传递一个参数，让Node直接为所有js文件开启严格模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node --use_strict calc.js</span><br></pre></td></tr></table></figure>

<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块化最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。</p>
<p>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。</p>
<p>例如：</p>
<ul>
<li>导出</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hello.js</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line">greet(name)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(s + <span class="string">&#x27; &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = greet;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//也可以直接 exports 但更推荐上面的方式</span></span><br><span class="line"><span class="built_in">exports</span> = greet</span><br></pre></td></tr></table></figure>



<ul>
<li>导入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;main.js</span><br><span class="line">&#x2F;&#x2F;导入刚刚的hello模块</span><br><span class="line">let greet &#x3D; require(&#39;.&#x2F;hello&#39;)</span><br></pre></td></tr></table></figure>

<h2 id="global"><a href="#global" class="headerlink" title="global"></a>global</h2><p>avaScript有且仅有一个全局对象，在浏览器中，叫<code>window</code>对象。而在Node.js环境中，也有唯一的全局对象，但不叫<code>window</code>，而叫<code>global</code>，这个对象的属性和方法也和浏览器环境的<code>window</code>不同。</p>
<p>在Node交互环境中输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> global.console</span></span><br><span class="line">Console &#123;</span><br><span class="line">  log: [Function: bound ],</span><br><span class="line">  info: [Function: bound ],</span><br><span class="line">  warn: [Function: bound ],</span><br><span class="line">  error: [Function: bound ],</span><br><span class="line">  dir: [Function: bound ],</span><br><span class="line">  time: [Function: bound ],</span><br><span class="line">  timeEnd: [Function: bound ],</span><br><span class="line">  trace: [Function: bound trace],</span><br><span class="line">  assert: [Function: bound ],</span><br><span class="line">  Console: [Function: Console] &#125;`</span><br></pre></td></tr></table></figure>

<h2 id="process"><a href="#process" class="headerlink" title="process"></a>process</h2><p><code>process</code>也是Node.js提供的一个对象，它代表当前Node.js进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> process === global.process;</span></span><br><span class="line">true</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> process.version;</span></span><br><span class="line">&#x27;v5.2.0&#x27;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> process.platform;</span></span><br><span class="line">&#x27;darwin&#x27;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> process.arch;</span></span><br><span class="line">&#x27;x64&#x27;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> process.cwd(); //返回当前工作目录</span></span><br><span class="line">&#x27;/Users/michael&#x27;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> process.chdir(<span class="string">&#x27;/private/tmp&#x27;</span>); // 切换当前工作目录</span></span><br><span class="line">undefined</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> process.cwd();</span></span><br><span class="line">&#x27;/private/tmp&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h3><p><code>process.nextTick()</code>接收一个函数。</p>
<p>传入<code>process.nextTick()</code>的函数不是立刻执行，而是要等到下一次事件循环。</p>
<p>即循环执行代码一次，等到第二次循环再执行<code>process.nextTick()</code>的内容</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// process.nextTick()将在下一轮事件循环中调用:</span></span><br><span class="line"><span class="keyword">let</span> nextTick1 = process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;next tick callback&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;next was set&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> nextTick2 = process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;next tick callback&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;next was set twice&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//输出</span><br><span class="line">next was set</span><br><span class="line">next was set twice</span><br><span class="line">next tick callback</span><br><span class="line">next tick callback</span><br></pre></td></tr></table></figure>

<p>执行过程：</p>
<ul>
<li>第一次循环代码<ul>
<li>跳过<code>nextTick1</code></li>
<li>执行<code>console.log(&#39;next was set&#39;)</code></li>
<li>跳过<code>nextTick2</code></li>
<li>执行<code>console.log(&#39;next was set twice&#39;)</code></li>
</ul>
</li>
<li>第二次循环代码<ul>
<li>执行<code>nextTick1</code></li>
<li>跳过<code>console.log(&#39;next was set&#39;)</code></li>
<li>执行<code>nextTick2</code></li>
<li>跳过<code>console.log(&#39;next was set twice&#39;)</code></li>
</ul>
</li>
</ul>
<h3 id="exit事件"><a href="#exit事件" class="headerlink" title="exit事件"></a>exit事件</h3><p>Node.js进程本身的事件就由<code>process</code>对象来处理。如果我们响应<code>exit</code>事件，就可以在程序即将退出时执行某个回调函数</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="comment">// 程序即将退出时的回调函数:</span></span><br><span class="line">process.on(<span class="string">&#x27;exit&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;about to exit with code: &#x27;</span> + code);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="判别JS执行环境"><a href="#判别JS执行环境" class="headerlink" title="判别JS执行环境"></a>判别JS执行环境</h3><p>有很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="comment">//通过独特的全局对象来判别</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span>(<span class="built_in">window</span>) === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;node.js&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;browser&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本模块"><a href="#基本模块" class="headerlink" title="基本模块"></a>基本模块</h2><h3 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h3><p>用于读写文件</p>
<h4 id="异步读取文本"><a href="#异步读取文本" class="headerlink" title="异步读取文本"></a>异步读取文本</h4><p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>回调函数需要两个参数：err，data</p>
<ul>
<li><p>正常情况下<code>err == null</code> , <code>data</code>为读取到的文本</p>
</li>
<li><p>发生错误时<code>err</code>为一个错误对象，<code>data == undefined</code></p>
</li>
</ul>
<h4 id="读取二进制文件（异步）"><a href="#读取二进制文件（异步）" class="headerlink" title="读取二进制文件（异步）"></a>读取二进制文件（异步）</h4><p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="comment">// 读取图片</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这里没有传入文件编码格式</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;sample.png&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">        <span class="built_in">console</span>.log(data.length + <span class="string">&#x27; bytes&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当读取二进制文件时，不传入文件编码时，回调函数的<code>data</code>参数将返回一个<code>Buffer</code>对象。在Node.js中，<code>Buffer</code>对象就是一个包含零个或任意个字节的数组（注意和Array不同）。</p>
<p><code>Buffer</code>对象可以和String作转换，例如，把一个<code>Buffer</code>对象转换成String：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Buffer -&gt; String</span></span><br><span class="line"><span class="comment">// text为Buffer</span></span><br><span class="line"><span class="keyword">var</span> text = data.toString(<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(text);</span><br></pre></td></tr></table></figure>

<h4 id="同步读取文件"><a href="#同步读取文件" class="headerlink" title="同步读取文件"></a>同步读取文件</h4><p>除了标准的异步读取模式外，<code>fs</code>也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个<code>Sync</code>后缀，并且不接收回调函数，函数直接返回结果。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="comment">// 同步读取</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = fs.readFileSync(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br></pre></td></tr></table></figure>

<p>如果同步读取发生错误，则需要用<code>try...catch</code>捕获</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异常处理</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data = fs.readFileSync(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 出错了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异步写文件"><a href="#异步写文件" class="headerlink" title="异步写文件"></a>异步写文件</h4><p>将数据写入文件是通过<code>fs.writeFile()</code>实现的</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = <span class="string">&#x27;Hello, Node.js&#x27;</span>;</span><br><span class="line">fs.writeFile(<span class="string">&#x27;output.txt&#x27;</span>, data, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;ok.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>writeFile()</code>的参数依次为文件名、数据和回调函数。如果传入的数据是String，默认按UTF-8编码写入文本文件，如果传入的参数是<code>Buffer</code>，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个<code>err</code>参数。</p>
<h4 id="同步写文件"><a href="#同步写文件" class="headerlink" title="同步写文件"></a>同步写文件</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = <span class="string">&#x27;Hello, Node.js&#x27;</span>;</span><br><span class="line">fs.writeFileSync(<span class="string">&#x27;output.txt&#x27;</span>, data);</span><br></pre></td></tr></table></figure>

<p>同样需要使用<code>try...catch</code>捕获异常</p>
<h4 id="获取文件信息-异步"><a href="#获取文件信息-异步" class="headerlink" title="获取文件信息(异步)"></a>获取文件信息(异步)</h4><p>如果我们要获取文件大小，创建时间等信息，可以使用<code>fs.stat()</code>，它返回一个<code>Stat</code>对象，能告诉我们文件或目录的详细信息</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.stat(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, stat</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 是否是文件:</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;isFile: &#x27;</span> + stat.isFile());</span><br><span class="line">        <span class="comment">// 是否是目录:</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;isDirectory: &#x27;</span> + stat.isDirectory());</span><br><span class="line">        <span class="keyword">if</span> (stat.isFile()) &#123;</span><br><span class="line">            <span class="comment">// 文件大小:</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;size: &#x27;</span> + stat.size);</span><br><span class="line">            <span class="comment">// 创建时间, Date对象:</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;birth time: &#x27;</span> + stat.birthtime);</span><br><span class="line">            <span class="comment">// 修改时间, Date对象:</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;modified time: &#x27;</span> + stat.mtime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="获取文件信息-同步"><a href="#获取文件信息-同步" class="headerlink" title="获取文件信息(同步)"></a>获取文件信息(同步)</h4><p><code>stat()</code>也有一个对应的同步函数<code>statSync()</code>，请试着改写上述异步代码为同步代码。</p>
<h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h3><p>流是一种抽象的数据结构。想象水流，当在水管中流动时，就可以从某个地方（例如自来水厂）源源不断地到达另一个地方（比如你家的洗手池）。我们也可以把数据看成是数据流，比如你敲键盘的时候，就可以把每个字符依次连起来，看成字符流。这个流是从键盘输入到应用程序，实际上它还对应着一个名字：标准输入流（stdin）。</p>
<p>如果应用程序把字符一个一个输出到显示器上，这也可以看成是一个流，这个流也有名字：标准输出流（stdout）。流的特点是数据是有序的，而且必须依次读取，或者依次写入，不能像Array那样随机定位</p>
<h4 id="使用流读取文件"><a href="#使用流读取文件" class="headerlink" title="使用流读取文件"></a>使用流读取文件</h4><p>​    一般步骤：创建一个文件流对象，响应<code>data</code>事件从文件流中读出数据，响应<code>end</code>事件关闭流</p>
<p>​    流也是一个对象，我们只需要响应流的事件就可以了：<code>data</code>事件表示流的数据已经可以读取了，<code>end</code>事件表示这个流已经到末尾了，没有数据可以读取了，<code>error</code>事件表示出错了。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开一个流:</span></span><br><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;DATA:&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(chunk);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;END&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;ERROR: &#x27;</span> + err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>要注意，<code>data</code>事件可能会有多次，每次传递的<code>chunk</code>是流的一部分数据。</p>
<p>要以流的形式写入文件，只需要不断调用<code>write()</code>方法，最后以<code>end()</code>结束：</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ws1 = fs.createWriteStream(<span class="string">&#x27;output1.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">ws1.write(<span class="string">&#x27;使用Stream写入文本数据...\n&#x27;</span>);</span><br><span class="line">ws1.write(<span class="string">&#x27;END.&#x27;</span>);</span><br><span class="line">ws1.end();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ws2 = fs.createWriteStream(<span class="string">&#x27;output2.txt&#x27;</span>);</span><br><span class="line">ws2.write(<span class="keyword">new</span> Buffer(<span class="string">&#x27;使用Stream写入二进制数据...\n&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>));</span><br><span class="line">ws2.write(<span class="keyword">new</span> Buffer(<span class="string">&#x27;END.&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>));</span><br><span class="line">ws2.end();</span><br></pre></td></tr></table></figure>

<h4 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h4><p>就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个<code>Readable</code>流和一个<code>Writable</code>流串起来后，所有的数据自动从<code>Readable</code>流进入<code>Writable</code>流，这种操作叫<code>pipe</code>。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">&#x27;sample.txt&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ws = fs.createWriteStream(<span class="string">&#x27;copied.txt&#x27;</span>);</span><br><span class="line"></span><br><span class="line">rs.pipe(ws);</span><br></pre></td></tr></table></figure>

<p> 注：当<code>Readable</code>流的数据读取完毕，<code>end</code>事件触发后，将自动关闭<code>Writable</code>流。如果我们不希望自动关闭<code>Writable</code>流，需要传入参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">readable.pipe(writable, &#123; <span class="attr">end</span>: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><p>要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的<code>http</code>模块完成了。应用程序并不直接和HTTP协议打交道，而是操作<code>http</code>模块提供的<code>request</code>和<code>response</code>对象。</p>
<p><code>request</code>对象封装了HTTP请求，我们调用<code>request</code>对象的属性和方法就可以拿到所有HTTP请求的信息；</p>
<p><code>response</code>对象封装了HTTP响应，我们操作<code>response</code>对象的方法，就可以把HTTP响应返回给浏览器。</p>
<h4 id="简单的服务器"><a href="#简单的服务器" class="headerlink" title="简单的服务器"></a>简单的服务器</h4><p>例如：</p>
<p>​    用Node.js实现一个HTTP服务器程序非常简单。我们来实现一个最简单的Web程序<code>hello.js</code>，它对于所有请求，都返回<code>Hello world!</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入http模块:</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建http server，并传入回调函数:</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 回调函数接收request和response对象,</span></span><br><span class="line">    <span class="comment">// 获得HTTP请求的method和url:</span></span><br><span class="line">    <span class="built_in">console</span>.log(request.method + <span class="string">&#x27;: &#x27;</span> + request.url);</span><br><span class="line">    <span class="comment">// 将HTTP响应200写入response, 同时设置Content-Type: text/html:</span></span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span>&#125;);</span><br><span class="line">    <span class="comment">// 将HTTP响应的HTML内容写入response:</span></span><br><span class="line">    response.end(<span class="string">&#x27;&lt;h1&gt;Hello world!&lt;/h1&gt;&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让服务器监听8080端口:</span></span><br><span class="line">server.listen(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at http://127.0.0.1:8080/&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="文件服务器"><a href="#文件服务器" class="headerlink" title="文件服务器"></a>文件服务器</h4><p>扩展一下上面的Web程序。我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析<code>request.url</code>中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。</p>
<h5 id="url解析"><a href="#url解析" class="headerlink" title="url解析"></a>url解析</h5><p>解析URL需要用到Node.js提供的<code>url</code>模块，它使用起来非常简单，通过<code>parse()</code>将一个字符串解析为一个<code>Url</code>对象：</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(url.parse(<span class="string">&#x27;http://user:pass@host.com:8080/path/to/file?query=string#hash&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Url &#123;</span><br><span class="line">  protocol: &#x27;http:&#x27;,</span><br><span class="line">  slashes: true,</span><br><span class="line">  auth: &#x27;user:pass&#x27;,</span><br><span class="line">  host: &#x27;host.com:8080&#x27;,</span><br><span class="line">  port: &#x27;8080&#x27;,</span><br><span class="line">  hostname: &#x27;host.com&#x27;,</span><br><span class="line">  hash: &#x27;#hash&#x27;,</span><br><span class="line">  search: &#x27;?query=string&#x27;,</span><br><span class="line">  query: &#x27;query=string&#x27;,</span><br><span class="line">  pathname: &#x27;/path/to/file&#x27;,</span><br><span class="line">  path: &#x27;/path/to/file?query=string&#x27;,</span><br><span class="line">  href: &#x27;http://user:pass@host.com:8080/path/to/file?query=string#hash&#x27; &#125;</span><br></pre></td></tr></table></figure>

<h5 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a>path模块</h5><p>处理本地文件目录需要使用Node.js提供的<code>path</code>模块，它可以方便地构造目录：</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析当前目录:</span></span><br><span class="line"><span class="keyword">var</span> workDir = path.resolve(<span class="string">&#x27;.&#x27;</span>); <span class="comment">// &#x27;/Users/michael&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合完整的文件路径:当前目录+&#x27;pub&#x27;+&#x27;index.html&#x27;:</span></span><br><span class="line"><span class="keyword">var</span> filePath = path.join(workDir, <span class="string">&#x27;pub&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>);</span><br><span class="line"><span class="comment">// &#x27;/Users/michael/pub/index.html&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>),</span><br><span class="line">    url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>),</span><br><span class="line">    path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>),</span><br><span class="line">    http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从命令行参数获取root目录，默认是当前目录:</span></span><br><span class="line"><span class="keyword">var</span> root = path.resolve(process.argv[<span class="number">2</span>] || <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Static root dir: &#x27;</span> + root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务器:</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获得URL的path，类似 &#x27;/css/bootstrap.css&#x27;:</span></span><br><span class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</span><br><span class="line">    <span class="comment">// 获得对应的本地文件路径，类似 &#x27;/srv/www/css/bootstrap.css&#x27;:</span></span><br><span class="line">    <span class="keyword">var</span> filepath = path.join(root, pathname);</span><br><span class="line">    <span class="comment">// 获取文件状态:</span></span><br><span class="line">    fs.stat(filepath, <span class="function"><span class="keyword">function</span> (<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!err &amp;&amp; stats.isFile()) &#123;</span><br><span class="line">            <span class="comment">// 没有出错并且文件存在:</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;200 &#x27;</span> + request.url);</span><br><span class="line">            <span class="comment">// 发送200响应:</span></span><br><span class="line">            response.writeHead(<span class="number">200</span>);</span><br><span class="line">            <span class="comment">// 将文件流导向response:</span></span><br><span class="line">            fs.createReadStream(filepath).pipe(response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 出错了或者文件不存在:</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;404 &#x27;</span> + request.url);</span><br><span class="line">            <span class="comment">// 发送404响应:</span></span><br><span class="line">            response.writeHead(<span class="number">404</span>);</span><br><span class="line">            response.end(<span class="string">&#x27;404 Not Found&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at http://127.0.0.1:8080/&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h3><p>crypto模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。Nodejs用C/C++实现这些算法后，通过cypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。</p>
<h4 id="MD5和SHA1"><a href="#MD5和SHA1" class="headerlink" title="MD5和SHA1"></a>MD5和SHA1</h4><p>MD5是一种常用的哈希算法，用于给任意数据一个“签名”。这个签名通常用一个十六进制的字符串表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const crypto &#x3D; require(&#39;crypto&#39;);</span><br><span class="line"></span><br><span class="line">const hash &#x3D; crypto.createHash(&#39;md5&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可任意多次调用update():</span><br><span class="line">hash.update(&#39;Hello, world!&#39;);</span><br><span class="line">hash.update(&#39;Hello, nodejs!&#39;);</span><br><span class="line"></span><br><span class="line">console.log(hash.digest(&#39;hex&#39;)); &#x2F;&#x2F; 7e1977739c748beac0c0fd14fd26a544</span><br></pre></td></tr></table></figure>

<p><code>update()</code>方法默认字符串编码为<code>UTF-8</code>，也可以传入Buffer。</p>
<p>如果要计算SHA1，只需要把<code>&#39;md5&#39;</code>改成<code>&#39;sha1&#39;</code>，就可以得到SHA1的结果<code>1f32b9c9932c02227819a4151feed43e131aca40</code>。</p>
<p>还可以使用更安全的<code>sha256</code>和<code>sha512</code>。</p>
]]></content>
      <tags>
        <tag>building</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC相关</title>
    <url>/2020/10/21/RPC%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">graph LR</span><br><span class="line">本地--&gt;|要执行的函数与函数参数|服务端</span><br><span class="line">服务端--&gt;|通过回调函数传回函数结果|本地</span><br></pre></td></tr></table></figure>

<p>以上传参过程均通过AJAX</p>
<h1 id="传输的数据"><a href="#传输的数据" class="headerlink" title="传输的数据"></a>传输的数据</h1><p><strong>本地：服务端的函数与函数参数</strong></p>
<p><strong>服务端：回调执行结果</strong></p>
<h1 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h1><p>将JSON序列化为PHP形式</p>
<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>RPC(Remote Procedure Call)指的是远程过程调用，简单的说，RPC就是从一台机器上通过参数传递的方式调用另一台机器上的一个函数或方法并得到响应结果。</p>
<p>即本地来调用远程计算机上的某个函数</p>
<p>我们不用关心RPC的通讯细节只需要使用上层接口</p>
]]></content>
  </entry>
  <entry>
    <title>ReadME!!</title>
    <url>/2220/09/20/ReadME!!!/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>欢迎访问！</li>
<li>第一次加载文章首页图可能很慢。。。</li>
<li>如要评论文章，请先填写昵称和邮箱（这两者为必要填写项）</li>
</ul>
]]></content>
      <tags>
        <tag>Hello!</tag>
      </tags>
  </entry>
  <entry>
    <title>java相关</title>
    <url>/2020/12/03/java%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>Java定义了一种名字空间，称之为包：<code>package</code>。一个类总是属于某个包，类名（比如<code>Person</code>）只是一个简写，真正的完整类名是<code>包名.类名</code>。</p>
<p>包作用域是指一个类允许访问同一个<code>package</code>的没有<code>public</code>、<code>private</code>修饰的<code>class</code>，以及没有<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法。</p>
<h1 id="关键字作用域"><a href="#关键字作用域" class="headerlink" title="关键字作用域"></a>关键字作用域</h1><h2 id="public"><a href="#public" class="headerlink" title="public"></a>public</h2><ul>
<li>class,interface可被其他任何class访问</li>
<li>class内部定义的字段必须要先有此class的访问权限才能访问</li>
</ul>
<p>**PS:**如果不确定是否需要<code>public</code>，就不声明为<code>public</code>，即尽可能少地暴露对外的字段和方法。</p>
<h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><ul>
<li><p>无法被其他类访问</p>
</li>
<li><p>可以被定义private字段的class的内部class访问</p>
</li>
</ul>
<h2 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h2><p><code>protected</code>作用于继承关系。定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类</p>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul>
<li><p>作用于class阻止class被继承</p>
</li>
<li><p>作用于class内的方法阻止方法被子类覆写</p>
</li>
<li><p>作用于变量阻止被重新赋值</p>
</li>
</ul>
<h1 id="classpath和jar"><a href="#classpath和jar" class="headerlink" title="classpath和jar"></a>classpath和jar</h1><p><code>classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索<code>class</code></p>
<p>假设<code>classpath</code>是<code>.;C:\work\project1\bin;C:\shared</code>，当JVM在加载<code>abc.xyz.Hello</code>这个类时，会依次查找：</p>
<ul>
<li>&lt;当前目录&gt;\abc\xyz\Hello.class</li>
<li>C:\work\project1\bin\abc\xyz\Hello.class</li>
<li>C:\shared\abc\xyz\Hello.class</li>
</ul>
<p>在启动JVM时设置<code>classpath</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -classpath .;C:\work\project1\bin;C:\shared abc.xyz.Hello</span><br><span class="line"></span><br><span class="line">java -cp .;C:\work\project1\bin;C:\shared abc.xyz.Hello</span><br></pre></td></tr></table></figure>

<h1 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h1><p>在Java中，有很多<code>class</code>的定义都符合这样的规范：</p>
<ul>
<li>若干<code>private</code>实例字段；</li>
<li>通过<code>public</code>方法来读写实例字段。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如下面这个class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这种class被称为JavaBean</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>Introspector.getBeanInfo()</code>可以获取属性列表。</li>
</ul>
<h1 id="enum枚举"><a href="#enum枚举" class="headerlink" title="enum枚举"></a>enum枚举</h1><p>为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用<code>enum</code>来定义枚举类：</p>
<p>​    Java使用<code>enum</code>定义枚举类型，它被编译器编译为<code>final class Xxx extends Enum &#123; … &#125;</code>；</p>
<p>​    这样定义了一个数据集合，我们可以自定义属于这个数据集合的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义Weekday类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Weekday day = Weekday.SUN;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>enum</code>定义的枚举类是一种引用类型。引用类型比较，要使用<code>equals()</code>方法，但是<code>enum</code>除外，这是因为<code>enum</code>类型的每个常量在JVM中只有一个唯一实例，所以可以直接用<code>==</code>比较</p>
<ul>
<li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且无法被继承；</li>
<li>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例；</li>
<li>定义的每个实例都是引用类型的唯一实例；</li>
<li>可以将<code>enum</code>类型用于<code>switch</code>语句。</li>
</ul>
<h2 id="enum的方法"><a href="#enum的方法" class="headerlink" title="enum的方法"></a>enum的方法</h2><ul>
<li><code>name()</code>：返回常量名</li>
<li><code>ordinal()</code>:返回定义常量的顺序，从0开始</li>
</ul>
<h2 id="为enum创建方法"><a href="#为enum创建方法" class="headerlink" title="为enum创建方法"></a>为enum创建方法</h2><p>可以为<code>enum</code>编写构造方法、字段和方法</p>
<p><code>enum</code>的构造方法要声明为<code>private</code>，字段强烈建议声明为<code>final</code>；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    MON(<span class="number">1</span>), TUE(<span class="number">2</span>), WED(<span class="number">3</span>), THU(<span class="number">4</span>), FRI(<span class="number">5</span>), SAT(<span class="number">6</span>), SUN(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> dayValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Weekday</span><span class="params">(<span class="keyword">int</span> dayValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dayValue = dayValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="记录类"><a href="#记录类" class="headerlink" title="记录类"></a>记录类</h1><h2 id="不变类"><a href="#不变类" class="headerlink" title="不变类"></a>不变类</h2><p>使用<code>String</code>、<code>Integer</code>等类型的时候，这些类型都是不变类，一个不变类具有以下特点：</p>
<ol>
<li>定义class时使用<code>final</code>，无法派生子类；</li>
<li>每个字段使用<code>final</code>，保证创建实例后无法修改任何字段。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不变类改记录类"><a href="#不变类改记录类" class="headerlink" title="不变类改记录类"></a>不变类改记录类</h2><p>从Java 14开始，引入了新的<code>Record</code>类。我们定义<code>Record</code>类时，使用关键字<code>record</code>。把上述<code>Point</code>类改写为<code>Record</code>类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//是的，就这一行</span></span><br><span class="line"><span class="comment">//等于</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">extends</span> <span class="title">Record</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Point[x=%s, y=%s]&quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了用<code>final</code>修饰class以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写<code>toString()</code>、<code>equals()</code>和<code>hashCode()</code>方法。</p>
<p>和<code>enum</code>类似，我们自己不能直接从<code>Record</code>派生，只能通过<code>record</code>关键字由编译器实现继承。</p>
<h3 id="检查数据"><a href="#检查数据" class="headerlink" title="检查数据"></a>检查数据</h3><p>既然编译器自动生成了方法，那我们要检查构造方法传入的数据要怎么办呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">extends</span> <span class="title">Record</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这是我们编写的Compact Constructor:</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这是编译器继续生成的赋值代码:</span></span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加静态方法"><a href="#添加静态方法" class="headerlink" title="添加静态方法"></a>添加静态方法</h3><p>作为<code>record</code>的<code>Point</code>仍然可以添加静态方法。一种常用的静态方法是<code>of()</code>方法，用来创建<code>Point</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">of</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">of</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常用库"><a href="#常用库" class="headerlink" title="常用库"></a>常用库</h1><h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Random r &#x3D; new Random();</span><br><span class="line">r.nextInt(); &#x2F;&#x2F; 2071575453,每次都不一样</span><br><span class="line">r.nextInt(10); &#x2F;&#x2F; 5,生成一个[0,10)之间的int</span><br><span class="line">r.nextLong(); &#x2F;&#x2F; 8811649292570369305,每次都不一样</span><br><span class="line">r.nextFloat(); &#x2F;&#x2F; 0.54335...生成一个[0,1)之间的float</span><br><span class="line">r.nextDouble(); &#x2F;&#x2F; 0.3716...生成一个[0,1)之间的double</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>mySQL基础</title>
    <url>/2020/11/30/mySQL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <tags>
        <tag>password</tag>
      </tags>
  </entry>
  <entry>
    <title>vue小项目</title>
    <url>/2020/12/25/vue%E5%B0%8F%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="vue项目"><a href="#vue项目" class="headerlink" title="vue项目"></a>vue项目</h1><p>基于Vue-CLI3</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><ul>
<li>创建文件夹</li>
<li>vue create ‘project name’(Vue-CLI3)</li>
<li>创建 GitHub 仓库</li>
</ul>
<h3 id="与git远程库连接"><a href="#与git远程库连接" class="headerlink" title="与git远程库连接"></a>与git远程库连接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &#39;初始化项目&#39;</span><br><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;.&#x2F;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h2 id="构造目录"><a href="#构造目录" class="headerlink" title="构造目录"></a>构造目录</h2><p>​    在新项目中，先构造目录是 一个很好的习惯</p>
<ul>
<li>assets用于存放静态资源，如css, img等</li>
<li>components的根目录一般存放公用组件，子目录存放区分更细致的组件</li>
</ul>
<h3 id="src的结构"><a href="#src的结构" class="headerlink" title="src的结构"></a>src的结构</h3><ul>
<li>assets<ul>
<li>css<ul>
<li>normalize.css(大佬写的通用css，用于处理各浏览器规范 [见github])</li>
<li>base.css(自己写的项目css规范)</li>
</ul>
</li>
<li>img</li>
</ul>
</li>
<li>common</li>
<li>components</li>
<li>network</li>
<li>router</li>
<li>store</li>
<li>views</li>
</ul>
<h2 id="配置文件夹别名"><a href="#配置文件夹别名" class="headerlink" title="配置文件夹别名"></a>配置文件夹别名</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    configureWebpack: &#123;</span><br><span class="line">        resolve: &#123;</span><br><span class="line">            alias: &#123;</span><br><span class="line">                <span class="string">&#x27;assets&#x27;</span>: <span class="string">&#x27;@/assets&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;common&#x27;</span>: <span class="string">&#x27;@/common&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;components&#x27;</span>: <span class="string">&#x27;@/components&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;network&#x27;</span>: <span class="string">&#x27;@/network&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;views&#x27;</span>: <span class="string">&#x27;@/views&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="撰写-editorconfig"><a href="#撰写-editorconfig" class="headerlink" title="撰写.editorconfig"></a>撰写.editorconfig</h2><p>.editorconfig 用于统一代码风格</p>
<p>p152</p>
]]></content>
  </entry>
  <entry>
    <title>MySQL相关</title>
    <url>/2020/09/19/mysql%E7%9B%B8%E5%85%B3(building)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL-（building）"><a href="#MySQL-（building）" class="headerlink" title="MySQL!（building）"></a>MySQL!（building）</h1><h2 id="启动与关闭"><a href="#启动与关闭" class="headerlink" title="启动与关闭"></a>启动与关闭</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqld --console</span><br><span class="line">&#x2F;&#x2F;启动</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqladmin -uroot shutdown</span><br><span class="line">&#x2F;&#x2F;关闭</span><br></pre></td></tr></table></figure>

<h2 id="用户设置"><a href="#用户设置" class="headerlink" title="用户设置"></a>用户设置</h2><p>添加用户的的实例，用户名为guest，密码为guest123，并授权用户可进行 SELECT, INSERT 和 UPDATE操作权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@host# mysql -u root -p</span><br><span class="line">Enter password:*******</span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO user </span><br><span class="line">          (host, user, password, </span><br><span class="line">           select_priv, insert_priv, update_priv) </span><br><span class="line">           VALUES (&#39;localhost&#39;, &#39;guest&#39;, </span><br><span class="line">           PASSWORD(&#39;guest123&#39;), &#39;Y&#39;, &#39;Y&#39;, &#39;Y&#39;);</span><br><span class="line">Query OK, 1 row affected (0.20 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT host, user, password FROM user WHERE user &#x3D; &#39;guest&#39;;</span><br><span class="line">+-----------+---------+------------------+</span><br><span class="line">| host      | user    | password         |</span><br><span class="line">+-----------+---------+------------------+</span><br><span class="line">| localhost | guest | 6f8c114b58f2ce9e |</span><br><span class="line">+-----------+---------+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>《关掉》</title>
    <url>/2020/10/16/%E3%80%8A%E5%85%B3%E6%8E%89%E3%80%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    关掉！关掉！一定要关掉！再不关掉那些网络游戏，小孩哪有美好的未来？哪有美好的前程？祖国哪有</p>
<h1 id="栋"><a href="#栋" class="headerlink" title="栋"></a>栋</h1><p>梁之才？</p>
<iframe src="//player.bilibili.com/player.html?aid=457253380&bvid=BV1s5411j7Po&cid=242488467&page=1" width="800px" height="450px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" auto="1"> </iframe>]]></content>
      <tags>
        <tag>关掉</tag>
      </tags>
  </entry>
  <entry>
    <title>很快啊</title>
    <url>/2020/11/08/%E5%BE%88%E5%BF%AB%E5%95%8A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>马老师发生甚么事了</p>
<p>我说怎么回事</p>
<p>给我发来几张截图</p>
<p>我一看，哦！原来是佐田</p>
<iframe src="//player.bilibili.com/player.html?aid=82179137&bvid=BV1HJ411L7DP&cid=140610898&page=1" scrolling="no" border="0" frameborder="no"
height = "450px" width="800px"framespacing="0" allowfullscreen="true" auto = "1"> </iframe>]]></content>
      <tags>
        <tag>我大意了啊，没有闪</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue相关</title>
    <url>/2020/12/14/Vue%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul>
<li>创建组件构造器 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cpN = Vue.extend(&#123;</span><br><span class="line">	template:<span class="string">&#x27;HTMLCODE&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>注册组件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;cpn&#x27;</span>,cpN)</span><br></pre></td></tr></table></figure>

<ul>
<li>组件使用</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="全局组件和局部组件"><a href="#全局组件和局部组件" class="headerlink" title="全局组件和局部组件"></a>全局组件和局部组件</h2><ul>
<li>Vue实例外注册的组件是全局组件</li>
<li>Vue实例内注册的组件为局部组件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//局部组件注册</span></span><br><span class="line">component:&#123;</span><br><span class="line">	cpn: cpN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="父子组件"><a href="#父子组件" class="headerlink" title="父子组件"></a>父子组件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cpn2 = Vue.extend(&#123;</span><br><span class="line">	template:<span class="string">`HTML CODE`</span>,</span><br><span class="line">&#125;)<span class="comment">//子组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cpn1 = Vue.extend(&#123;</span><br><span class="line">	template:<span class="string">`HTML CODE</span></span><br><span class="line"><span class="string">				&lt;cpn&gt;&lt;/cpn&gt;`</span>,</span><br><span class="line"><span class="comment">//这里的cpn是cpn2在cpn1内注册的组件</span></span><br><span class="line">	components:&#123;</span><br><span class="line">		cpn: cpn2</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;)<span class="comment">//父组件</span></span><br></pre></td></tr></table></figure>

<p><strong><em>注意：**</em></strong>cpn2因未在全局注册，所以仅能在cpn1中调用，不能在Vue挂载的部分使用**</p>
<hr>
<h2 id="更推荐的组件创建方式"><a href="#更推荐的组件创建方式" class="headerlink" title="更推荐的组件创建方式"></a>更推荐的组件创建方式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;cpn1&#x27;</span>,&#123;</span><br><span class="line">	template: <span class="string">`HTML CODE`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="HTML-CODE分离写法"><a href="#HTML-CODE分离写法" class="headerlink" title="HTML CODE分离写法"></a><code>HTML CODE</code>分离写法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scriprt</span> <span class="attr">type</span>=<span class="string">&#x27;text/x-template&#x27;</span> <span class="attr">id</span>=<span class="string">&#x27;cpn&#x27;</span>&gt;</span></span><br><span class="line">	SOME HTML CODE</span><br><span class="line"><span class="tag">&lt;/<span class="name">scriprt</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Vue.component(&#x27;cpn&#x27;&#123;</span><br><span class="line">	template: &#x27;#cpn&#x27;,</span><br><span class="line">	//这里的template的内容即是<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>标签里的&#x27;SOME HTML CODE&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>OR</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&#x27;cpn  &#x27;</span>&gt;</span></span><br><span class="line">	SOME HTML CODE</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Vue.component(&#x27;cpn&#x27;&#123;</span><br><span class="line">	template: &#x27;#cpn&#x27;,</span><br><span class="line">	//这里的template的内容即是<span class="tag">&lt;<span class="name">template</span>&gt;</span>标签里的&#x27;SOME HTML CODE&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="组件访问数据的范围"><a href="#组件访问数据的范围" class="headerlink" title="组件访问数据的范围"></a>组件访问数据的范围</h2><ul>
<li>组件不能直接访问Vue实例的data</li>
</ul>
<p><code>component</code>内也有data选项，<strong>但是data选项应该是一个返回对象的函数而不是对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;cpn&#x27;</span>,&#123;</span><br><span class="line">	template: <span class="string">`HTML CODE`</span>,</span><br><span class="line">	data()&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">            message: <span class="number">2</span>,</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>为什么data不能是对象？？</p>
<p>​    因为当有多个组件实例时，若data是对象则多个实例会共享data里的值，而将data设计为函数，每次实例化组件时都会为当前组件调用data函数返回一个对象，与其余实例不共享。所以在设计Vue的时候才会这样设计，强行写为对象会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">example()&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		value:<span class="number">1</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = example();</span><br><span class="line"><span class="keyword">const</span> b = example(); <span class="comment">//每次实例化都创建一个新的对象，a,b地址不同</span></span><br><span class="line">b.value = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//此时a.value = 1; b.value = 2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	value:<span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line">example()&#123;</span><br><span class="line">	<span class="keyword">return</span> obj; <span class="comment">//return的是obj的地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a  = example();</span><br><span class="line"><span class="keyword">const</span> b = example();</span><br><span class="line">b.value = <span class="number">2</span>;</span><br><span class="line">a.value == b.value <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h2 id="父子组件的通信"><a href="#父子组件的通信" class="headerlink" title="父子组件的通信"></a>父子组件的通信</h2><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><p>通过<code>props</code>属性传递，<code>props</code>可以是数组也可以是对象</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cpn</span> <span class="attr">:Cmessage</span>=<span class="string">&#x27;message&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span><span class="comment">&lt;!--绑定VM实例下的message到cpn的props下的Cmessage--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&#x27;cpn&#x27;</span>&gt;</span>&#123;&#123;Cmessage&#125;&#125;<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//子组件</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> cpn = &#123;</span></span><br><span class="line"><span class="javascript">        template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">//props:[&#x27;Cmessage&#x27;] //数组写法</span></span></span><br><span class="line">        props:&#123; </span><br><span class="line"><span class="javascript">        	<span class="comment">//Cmessage: String, //这里的String是对Cmessage进行类型限制，必须为String</span></span></span><br><span class="line"><span class="javascript">  			<span class="comment">//这是完整写法，为一个对象</span></span></span><br><span class="line">            Cmessage:&#123;</span><br><span class="line"><span class="javascript">                type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">                <span class="keyword">default</span>: <span class="string">&#x27;default value&#x27;</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">require</span>: <span class="comment">//这里填一个Boolean，表示组件创建时此值是不是必须的</span></span></span><br><span class="line">            &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">        data()&#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;&#125;;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">   	<span class="comment">//父组件</span></span></span><br><span class="line"><span class="javascript">	<span class="keyword">const</span> VM = <span class="keyword">new</span>  Vue()&#123;</span></span><br><span class="line"><span class="javascript">		el:<span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line">    	data:&#123;</span><br><span class="line"><span class="javascript">        	message: <span class="string">&#x27;this is a message&#x27;</span></span></span><br><span class="line">    	&#125;,</span><br><span class="line">    	components: &#123;</span><br><span class="line">			cpn: cpn</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong><em>注意：**</em></strong><code>props</code>的验证还可以自定义**</p>
<h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><p>通过自定义事件</p>
<p>$emit(‘event-name’,props)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cpn</span> <span class="attr">:Cmessage</span>=<span class="string">&#x27;message&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&#x27;cpn&#x27;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;clicked(Cmessage)&#x27;</span>&gt;</span> //点击事件发生主席那个clicked并以Cmessage作为参数</span><br><span class="line">	emit click</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//子组件</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> cpn = &#123;</span></span><br><span class="line"><span class="javascript">        template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line">        props:&#123; </span><br><span class="line">            Cmessage:&#123;</span><br><span class="line"><span class="javascript">                type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">                <span class="keyword">default</span>: <span class="string">&#x27;Cmessage &#x27;</span></span></span><br><span class="line">            &#125; </span><br><span class="line">    	&#125;</span><br><span class="line">        data()&#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line">                </span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">         methods:&#123;</span><br><span class="line">          	clicked(Cmessage)&#123;           </span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.$emit(<span class="string">&#x27;cpn-click&#x27;</span>Cmessage)<span class="comment">//发射cpn-click事件到父组件，并传Cmessage</span></span></span><br><span class="line">            &#125;   </span><br><span class="line">         &#125;        </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="comment">//父组件</span></span></span><br><span class="line"><span class="javascript">	<span class="keyword">const</span> VM = <span class="keyword">new</span>  Vue()&#123;</span></span><br><span class="line"><span class="javascript">		el:<span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line">    	data:&#123;</span><br><span class="line"><span class="javascript">        	message: <span class="string">&#x27;this is a message&#x27;</span></span></span><br><span class="line">    	&#125;,</span><br><span class="line">    	components: &#123;</span><br><span class="line">			cpn: cpn</span><br><span class="line">    	&#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            cpn-click(Cmessage)&#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(Cmessage);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p><strong>this.$children</strong>可以获取this（Vue实例）的子组件数组通过下标来查询具体某一项组件（不推荐这种方式）</p>
<p><strong>$refs</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cpn</span> <span class="attr">ref</span>=<span class="string">&#x27;a&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span>//若有一个组件像这样添加了refs属性</span><br><span class="line"></span><br><span class="line">this.$refs.a//则可以这样来获取此组件</span><br></pre></td></tr></table></figure>

<p><strong>$parent</strong>可以获取组件的父组件</p>
<p><strong>$root</strong>可以访问根组件</p>
<h2 id="插槽slot"><a href="#插槽slot" class="headerlink" title="插槽slot"></a>插槽slot</h2><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ul>
<li>slot定义</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&#x27;cpn&#x27;</span>&gt;</span></span><br><span class="line">	HTMLCODE</span><br><span class="line">	<span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;slot&gt;&lt;p&gt;default value&lt;/p&gt;&lt;/slot&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--插槽还可以具有默认值,手动赋值会覆盖此默认值--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里为cpn组件预留了一个slot插槽</p>
<ul>
<li>插槽使用</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">//这里把slot替换为了一个button</span><br></pre></td></tr></table></figure>

<h3 id="slot的name"><a href="#slot的name" class="headerlink" title="slot的name"></a>slot的name</h3><p>默认替换的是无name属性的插槽</p>
<p>若要选定某name的插槽,则需要</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>组件组件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>left<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>center<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>right<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">&#x27;left&#x27;</span>&gt;</span>left will be cover<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>想要把子组件的数据传到父组件进行显示，如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--以下方式是无法取到cpn里的things的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">    	</span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cpn</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&#x27;item in things&#x27;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!---------------------------------------------&gt;</span></span><br><span class="line"><span class="comment">&lt;!--要想完成上述目标则需要如下--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">slot</span> <span class="attr">:things</span> = <span class="string">&#x27;things&#x27;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这里的:things可以是任何自定标识符--&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">slot-scope</span> = <span class="string">&#x27;slot&#x27;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这里的&#x27;slot&#x27;也是可以自定义的--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&#x27;item in slot.things&#x27;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">	el:<span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line">	data:&#123;&#125;,</span><br><span class="line">	components:&#123;</span><br><span class="line">		cpn:&#123;</span><br><span class="line">			template:</span><br><span class="line">			data()&#123;</span><br><span class="line"><span class="javascript">				things:[<span class="string">&#x27;thing1&#x27;</span>,<span class="string">&#x27;thing2&#x27;</span>].</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>看下面的代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>app.isShow<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">&#x27;isShow&#x27;</span>&gt;</span>cpn.isShow<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cpn</span> <span class="attr">v-show</span>=<span class="string">&#x27;isShow&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">	el:<span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line">	data:&#123;</span><br><span class="line"><span class="javascript">		isShow:<span class="literal">true</span>,</span></span><br><span class="line">	&#125;,</span><br><span class="line">	components:&#123;</span><br><span class="line">		tempalte: ,</span><br><span class="line">		data()&#123;</span><br><span class="line"><span class="javascript">			<span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="javascript">				isShow:<span class="literal">false</span>,</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">//cpn的v-show会绑定到Vue实例app的isShow</span><br><span class="line">//cpn内的div的v-show会绑定到cpn的isShow</span><br></pre></td></tr></table></figure>

<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><h2 id="为什么需要模块化？"><a href="#为什么需要模块化？" class="headerlink" title="为什么需要模块化？"></a>为什么需要模块化？</h2><p>为了避免同一个项目下各个文件中变量作用域冲突造成的奇怪问题和节省开发成本</p>
<p>老旧的做法是使用匿名函数和模块导出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mouduleA = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">	<span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1+num2;</span><br><span class="line">	&#125;</span><br><span class="line">	obj.flag = flag;</span><br><span class="line">	obj.sum = sum;</span><br><span class="line">	<span class="keyword">return</span> obj</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//现在mouduleA为obj,可以在其他js文件中通过mouduleA.flag和moduleA.sum(num1,num2)来调用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>常用的模块化规范：</strong></p>
<ul>
<li>CommonJS(node.js)</li>
<li>AMD</li>
<li>CMD</li>
<li>Modules</li>
</ul>
<h2 id="CommonJS做法"><a href="#CommonJS做法" class="headerlink" title="CommonJS做法"></a>CommonJS做法</h2><p><strong>node环境下</strong></p>
<ul>
<li>导出</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个名为moduleA.js的文件</span></span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">	flag, <span class="comment">//也可以写成flag:flag,</span></span><br><span class="line">	sum,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>导入</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> moduleA = <span class="built_in">require</span>(<span class="string">&#x27;moduleA.js&#x27;</span>)</span><br><span class="line"><span class="comment">//现在可以通过mouduleA.flag和moduleA.sum()来获取</span></span><br></pre></td></tr></table></figure>

<h2 id="ES6做法"><a href="#ES6做法" class="headerlink" title="ES6做法"></a>ES6做法</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;moduleA.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&gt;&lt;/script&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">&lt;!--规定type=&quot;</span><span class="attr">module</span>&quot;后，每个<span class="attr">js</span>文件都有单独的空间，其余<span class="attr">js</span>文件不得直接访问，需要导出<span class="attr">--</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>导出</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个名叫moduleA.js的文件</span></span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//导出</span></span><br><span class="line"><span class="keyword">export</span>&#123;flag,sum&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>导入</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;flag,sum&#125; <span class="keyword">from</span> <span class="string">&quot;moduleA.js&quot;</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> mouduleA（别名） <span class="keyword">from</span> <span class="string">&#x27;moduleA.js&#x27;</span></span><br><span class="line"><span class="comment">//这样可以通过mouduleA.flag来取得变量</span></span><br></pre></td></tr></table></figure>

<h3 id="PS-export-default"><a href="#PS-export-default" class="headerlink" title="PS(export default)"></a>PS(export default)</h3><ul>
<li>导出</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//moduleA.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> flag</span><br><span class="line"><span class="comment">//export default 只能导出一项</span></span><br></pre></td></tr></table></figure>

<ul>
<li>导入</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> f <span class="keyword">from</span> <span class="string">&#x27;moduleA.js&#x27;</span></span><br><span class="line"><span class="comment">//这里的f就是moduleA.js中的flag</span></span><br></pre></td></tr></table></figure>

<h1 id="Webpack与node"><a href="#Webpack与node" class="headerlink" title="Webpack与node"></a>Webpack与node</h1><p> 前端模块化打包工具</p>
<p>webpack依赖node环境</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//安装webpack</span></span><br><span class="line">npm init</span><br><span class="line">npm install （--save-dev） webpack@版本号 -g</span><br><span class="line"><span class="comment">//--save-dev 是本地安装webpack命令</span></span><br></pre></td></tr></table></figure>



<h2 id="webpack配置文件"><a href="#webpack配置文件" class="headerlink" title="webpack配置文件"></a>webpack配置文件</h2><p>创建一个**<em>webpack.config.js**</em>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js内容</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>) <span class="comment">//导入node中的path</span></span><br><span class="line"></span><br><span class="line">moudule.exports=&#123;</span><br><span class="line">    <span class="comment">//表示打包的入口文件</span></span><br><span class="line">    entry: <span class="string">&#x27;./src/main.js&#x27;</span></span><br><span class="line">    <span class="comment">//表示打包形成的目标文件</span></span><br><span class="line">    output:&#123;</span><br><span class="line">    	path: path.reslove(__dirname，<span class="string">&#x27;dist&#x27;</span>), <span class="comment">//path必须是绝对路径，这里动态获取__dirname是node里获取当前路径的常量</span></span><br><span class="line">    	filename:<span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;meetwebpack&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">      <span class="comment">//创建npm run bulid 和webpack命令的映射</span></span><br><span class="line">     <span class="attr">&quot;bulid&quot;</span>: <span class="string">&quot;webpack&quot;</span> </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若在命令行键入npm run bulid则等效于键入webpack命令</span></span><br><span class="line"><span class="comment">//并且优先在本地webpack中(./node_modules/bin)找命令 </span></span><br></pre></td></tr></table></figure>

<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><h3 id="npm安装loader-以css为例"><a href="#npm安装loader-以css为例" class="headerlink" title="npm安装loader(以css为例)"></a>npm安装loader(以css为例)</h3><ul>
<li>安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev css-loader</span><br><span class="line">npm install --save-dev style-loader</span><br></pre></td></tr></table></figure>

<ul>
<li>配置</li>
</ul>
<p>在webpack.config.js中配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;新添加module对象，如下</span><br><span class="line">module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">            test: &#x2F;\.css$&#x2F;,</span><br><span class="line">            use: [&#39;style-loader&#39;, &#39;css-loader&#39;]</span><br><span class="line">            &#x2F;&#x2F;css-loader负责解析加载css</span><br><span class="line">            &#x2F;&#x2F;style-loader负责提交css到DOM上</span><br><span class="line">        	&#125;</span><br><span class="line">           	  ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>**注意:**有时候css-loader与style-loader的版本过高或者过低会出现问题，这时候在package.json里手动调低或者调高版本号即可</p>
<h3 id="图片loader"><a href="#图片loader" class="headerlink" title="图片loader"></a>图片loader</h3><ul>
<li>安装url-loader</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev url-loader</span><br></pre></td></tr></table></figure>

<ul>
<li>webpack.config.js配置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line"><span class="comment">//当加载的图片小于limit的字节数，图片url会被编译称base64字符串形式</span></span><br><span class="line"><span class="comment">//如果大于limt则会通过file-loader来编译，file-loader不需要特别配置</span></span><br><span class="line">              limit: <span class="number">8192</span>,</span><br><span class="line"><span class="comment">//name是指通过file-loader生成的图片打包在dist下的img文件夹且命名为:原文件名+8位hash值+扩展名</span></span><br><span class="line">              name: <span class="string">&#x27;img/[name].[hash:8].[ext]&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file-loader安装</span></span><br><span class="line">npm install --save-dev file-loader@版本号 </span><br></pre></td></tr></table></figure>

<p>注:**通过file-loader加载图片，路径会在output中path所指的文件夹中，</p>
<p>​    若html入口程序不在dist则浏览器无法正确找到</p>
<p>​    需要在webpack.config.js的output中修改配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">publicPath: <span class="string">&#x27;dist/&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="ES6转ES5"><a href="#ES6转ES5" class="headerlink" title="ES6转ES5"></a>ES6转ES5</h3><ul>
<li><strong>工具: babel</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//安装，这是一个旧版的babel</span></span><br><span class="line">npm install --save-dev babel-loader@<span class="number">7</span> babel-core babel-preset-es2015</span><br></pre></td></tr></table></figure>

<ul>
<li>配置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      <span class="comment">// exclude是写入不进行转换操作的文件夹</span></span><br><span class="line">      exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [<span class="string">&#x27;es2015&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="wepack配置Vue"><a href="#wepack配置Vue" class="headerlink" title="wepack配置Vue"></a>wepack配置Vue</h2><ul>
<li>安装</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install vue</span><br></pre></td></tr></table></figure>

<ul>
<li>引入</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//这里会直接在node_modules里找vue</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>需要在webpack.config.js中配置下面这一段代码来处理runtime-only和runtime-compiler的问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line"><span class="comment">//这里设置了import Vue from &#x27;vue&#x27;时vue的寻找路径，包含了runtime-compiler</span></span><br><span class="line">            <span class="string">&#x27;vue$&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>runtime-only不能编译vue模板</p>
<p>runtime-compiler可以编译</p>
<h2 id="Vue如何简化开发"><a href="#Vue如何简化开发" class="headerlink" title="Vue如何简化开发"></a>Vue如何简化开发</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">	template:<span class="string">`</span></span><br><span class="line"><span class="string">	&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">	`</span>,</span><br><span class="line">	data&#123;</span><br><span class="line">		message:<span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">//这里Vue会把template的内容直接拷贝到挂载的html文档上</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>第一种开发方式</li>
</ul>
<p>在vue实例内写html模板</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">        &lt;h3&gt;&#123;&#123;name&#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">        &lt;button @click=&#x27;btnclick&#x27;&gt;click&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">        name: <span class="string">&#x27;EE&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        btnClick() &#123;</span><br><span class="line">            alert(<span class="string">&#x27;click??&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>第二种开发方式</li>
</ul>
<p>在组件内写html模板把此组件作为Vue实例的子组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = &#123;</span><br><span class="line">    template: <span class="string">` </span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">        &lt;h3&gt;&#123;&#123;name&#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">        &lt;button @click=&#x27;btnClick&#x27;&gt;click&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">        name: <span class="string">&#x27;EE&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        btnClick() &#123;</span><br><span class="line">            alert(<span class="string">&#x27;click??&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    template: <span class="string">`&lt;App/&gt;`</span>,</span><br><span class="line">    components: &#123;</span><br><span class="line">        App,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>第三种方式</li>
</ul>
<p>把组件抽离成一个单独的js文件后导出，再在main.js中引入此组件即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line"> <span class="keyword">const</span> App = &#123;</span><br><span class="line">     template: <span class="string">` </span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">        &lt;h3&gt;&#123;&#123;name&#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">        &lt;button @click=&#x27;btnClick&#x27;&gt;click&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">     data() &#123;</span><br><span class="line">         <span class="keyword">return</span> &#123;</span><br><span class="line">             message: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">             name: <span class="string">&#x27;EE&#x27;</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     methods: &#123;</span><br><span class="line">         btnClick() &#123;</span><br><span class="line">             alert(<span class="string">&#x27;click??&#x27;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./src/js/vue/app.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    template: <span class="string">`&lt;App/&gt;`</span>,</span><br><span class="line">    components: &#123;</span><br><span class="line">        App,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>第四种开发方式</li>
</ul>
<p>创建.vue文件,将组件的模板，js代码，样式整合到vue文件中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//app.vue</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&#x27;title&#x27;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;btnClick&#x27;</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name:<span class="string">&#x27;App&#x27;</span>,</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="javascript">         <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">             message: <span class="string">&#x27;hello&#x27;</span>,</span></span><br><span class="line"><span class="javascript">             name: <span class="string">&#x27;EE&#x27;</span></span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     methods: &#123;</span><br><span class="line">         btnClick() &#123;</span><br><span class="line"><span class="javascript">             alert(<span class="string">&#x27;click??&#x27;</span>);</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.title</span>&#123;</span></span><br><span class="line">        color: blue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./src/js/vue/app.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    template: <span class="string">`&lt;App/&gt;`</span>,</span><br><span class="line">    components: &#123;</span><br><span class="line">        App,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>需要安装vue-loader vue-template-compiler</p>
<ul>
<li>安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue-loader@15.4.2 vue-template-compiler@2.5.21 --save-dev</span><br></pre></td></tr></table></figure>

<ul>
<li>配置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">    use: [<span class="string">&#x27;vue-loader&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><h3 id="添加一个版权提示插件"><a href="#添加一个版权提示插件" class="headerlink" title="添加一个版权提示插件"></a>添加一个版权提示插件</h3><p>BannerPlugin是webpack自带的所以不用另外下载</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">	plugins:[</span><br><span class="line">		<span class="keyword">new</span> webpack.BannerPlugin(<span class="string">&quot;最终解释权归EE所有&quot;</span>)</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h3><p>生成index.html到dist</p>
<ul>
<li>安装</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure>

<ul>
<li>配置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plugins:[</span><br><span class="line">	<span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template:<span class="string">&#x27;index.html&#x27;</span><span class="comment">//根据index.html为模板生成</span></span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="JS压缩插件"><a href="#JS压缩插件" class="headerlink" title="JS压缩插件"></a>JS压缩插件</h3><ul>
<li>安装</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install uglifyjs-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure>

<ul>
<li>配置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyjsWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>)</span><br><span class="line">plugins:&#123;</span><br><span class="line">    <span class="keyword">new</span> UgilifyjsWebpackPlugin()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="本地node服务器"><a href="#本地node服务器" class="headerlink" title="本地node服务器"></a>本地node服务器</h2><p>本地内存启用服务器，加快调试速度</p>
<ul>
<li>安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npn install webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure>

<ul>
<li>配置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line">devServer:&#123;</span><br><span class="line">	contentBase:<span class="string">&#x27;./dist&#x27;</span>,<span class="comment">//选定服务dist文件夹</span></span><br><span class="line">    inline:<span class="literal">true</span>,<span class="comment">//实时监听</span></span><br><span class="line">    port:<span class="comment">//端口号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//package.json</span></span><br><span class="line"><span class="string">&quot;script&quot;</span>:&#123;</span><br><span class="line">	<span class="string">&quot;dev&quot;</span>:<span class="string">&quot;webpack-dev-server --open&quot;</span><span class="comment">//映射到dev</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>启动</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<h2 id="webpack开发时配置和发布时配置分离"><a href="#webpack开发时配置和发布时配置分离" class="headerlink" title="webpack开发时配置和发布时配置分离"></a>webpack开发时配置和发布时配置分离</h2><p>生产和开发时的配置大多数时都不相同，把不同时期的配置文件分开管理是一个比较好的做法</p>
<p>项目根目录下建立文件夹config,包含一下三个文件</p>
<p>**base.config.js:**基础配置</p>
<p><strong>dev.config.js</strong>开发时配置</p>
<p><strong>prod.config.js</strong>生产打包配置</p>
<ul>
<li>安装webpack-merge</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack-merge --save-dev</span><br></pre></td></tr></table></figure>

<ul>
<li>配置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dev.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackMerge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">&#x27;./base.config.js&#x27;</span>)<span class="comment">//拿到base.config.js的内容</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackMerge(baseConfig,&#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        ...<span class="comment">//开发时需要的plugins</span></span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//prod.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackMerge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">&#x27;./base.config.js&#x27;</span>)<span class="comment">//拿到base.config.js的内容</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackMerge(baseConfig,&#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        ...<span class="comment">//生产打包需要的plugins</span></span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>我们需要重新指定package.json里的script项才能使得命令绑定且使用我们想要的配置文件</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//package.json</span></span><br><span class="line"><span class="string">&quot;script&quot;</span>:&#123;</span><br><span class="line">	<span class="string">&quot;bulid&quot;</span>: <span class="string">&quot;webpack --config ./bulid/prod.config.js&quot;</span>,</span><br><span class="line">	<span class="string">&quot;dev&quot;</span>:<span class="string">&quot;webpack-dev-server --open --config ./bulid/dev.config.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行打包</strong></p>
<p>​    发现打包的文件夹dist放在了当前config目录下</p>
<p>修改base.config.js下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">path: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>),</span><br></pre></td></tr></table></figure>

<h1 id="Vue-CLI-version-3"><a href="#Vue-CLI-version-3" class="headerlink" title="Vue CLI(version-3)"></a>Vue CLI(version-3)</h1><p>快速生成Vue开发环境，自动配置webpack</p>
<h2 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h2><ul>
<li>安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h2 id="CLI安装"><a href="#CLI安装" class="headerlink" title="CLI安装"></a>CLI安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g @vue&#x2F;cli@版本号vue -v</span><br></pre></td></tr></table></figure>

<h2 id="VueCLI-version-2"><a href="#VueCLI-version-2" class="headerlink" title="VueCLI(version-2)"></a>VueCLI(version-2)</h2><ul>
<li>创建项目</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue init webpack 项目名</span><br></pre></td></tr></table></figure>

<ul>
<li>流程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Project name (项目名)</span><br><span class="line">Project description  &#x2F;&#x2F;项目描述</span><br><span class="line">Author &#x2F;&#x2F;作者</span><br><span class="line"></span><br><span class="line">Runtime + Compiler:</span><br><span class="line">Runtime-only:</span><br><span class="line"></span><br><span class="line">Install vue-router?</span><br><span class="line">Use ESlint to lint your code?  &#x2F;&#x2F;检查代码规范</span><br><span class="line">Set up unit tests              &#x2F;&#x2F;单元测试</span><br><span class="line">Setup e2e tests with Nightwatch &#x2F;&#x2F;依赖Nightwatch的端到端测试</span><br></pre></td></tr></table></figure>

<h2 id="runtimeonly"><a href="#runtimeonly" class="headerlink" title="runtimeonly"></a>runtimeonly</h2><p>此版下vue工作流程</p>
<p>render -&gt; virtual dom -&gt;DOM</p>
<h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p><code>template</code>会被解析为render</p>
<p>.vue文件会被解析为render可处理的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">creatElement</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> createElement(<span class="string">&#x27;h2&#x27;</span>,</span><br><span class="line">          &#123;<span class="attr">class</span>:<span class="string">&#x27;box&#x27;</span>&#125;,</span><br><span class="line">          [<span class="string">&#x27;content&#x27;</span>,createElement(<span class="string">&#x27;button&#x27;</span>,[button])]         )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个render将创建一个</span></span><br><span class="line"><span class="comment">//&lt;h2 class=&#x27;box&#x27;&gt;content&lt;button&gt;button&lt;/button&gt;&lt;/h2&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>传入组件对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cpn = &#123;</span><br><span class="line">	template:<span class="string">&#x27;&lt;div&gt;hello &#123;&#123;message&#125;&#125;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            message:ee</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render:<span class="function"><span class="keyword">function</span>(<span class="params">creatElement</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> creatElement(cpn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="runtime-compiler"><a href="#runtime-compiler" class="headerlink" title="runtime + compiler"></a>runtime + compiler</h2><p>此版下vue工作流程</p>
<p>template -&gt; ast -&gt; render -&gt; virtual dom -&gt;DOM</p>
<h2 id="ES6箭头函数"><a href="#ES6箭头函数" class="headerlink" title="ES6箭头函数"></a>ES6箭头函数</h2><p>多用于将函数作为参数传入时</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传统函数</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//箭头函数</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">num</span>) =&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单个参数简写"><a href="#单个参数简写" class="headerlink" title="单个参数简写"></a>单个参数简写</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一般箭头函数</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">num</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num*num</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//省略后</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">num</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num*num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="仅一行代码时简写"><a href="#仅一行代码时简写" class="headerlink" title="仅一行代码时简写"></a>仅一行代码时简写</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一般写法</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">num</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num*num</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//省略写法</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">num</span>) =&gt;</span> num*num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------无返回值时--------------//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一般写法</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">num</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简写</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">num</span>) =&gt;</span> <span class="built_in">console</span>.log(num)</span><br></pre></td></tr></table></figure>

<h3 id="箭头函数中this的指向问题"><a href="#箭头函数中this的指向问题" class="headerlink" title="箭头函数中this的指向问题"></a>箭头函数中this的指向问题</h3><h1 id="VUE-router"><a href="#VUE-router" class="headerlink" title="VUE-router"></a>VUE-router</h1><h2 id="后端路由"><a href="#后端路由" class="headerlink" title="后端路由"></a>后端路由</h2><p>由后端处理URL和HTML文档的映射关系</p>
<h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h2><p>后端只提供数据，前端请求后端数据并展示</p>
<h2 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h2><p>SPA页面</p>
<p>仅一个静态资源(html css js) 页面</p>
<p>根据用户意愿来抽离出静态资源的某部分来展示</p>
<h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><ul>
<li>安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save vue-router</span><br></pre></td></tr></table></figure>

<p>**PS:**CLI创建时可自动安装</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul>
<li><p>src下创建router文件夹</p>
</li>
<li><p>router下创建一个index.js</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引入</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//安装插件</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">//配置路径和组件的映射关系</span></span><br><span class="line">  routes: [</span><br><span class="line">      &#123;</span><br><span class="line">        path:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="comment">//重定向默认网页到首页home</span></span><br><span class="line">        redirect:<span class="string">&#x27;/home&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path:<span class="string">&#x27; &#x27;</span>,</span><br><span class="line">        component:</span><br><span class="line">    &#125;</span><br><span class="line">  ]，</span><br><span class="line">    <span class="comment">//将路由模式选择为history模式</span></span><br><span class="line">    mode:<span class="string">&#x27;history&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router/index.js&#x27;</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	router: router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>router-link</li>
<li>router-view</li>
</ul>
<p>在根vue组件的template中添加</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--router-link会渲染为通向to的&lt;a&gt;&lt;/a&gt;标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&#x27;/home1&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&#x27;/home2&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&#x27;/home3&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--router-view用来显示所指向的组件内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<hr>
<h3 id="router-link详解"><a href="#router-link详解" class="headerlink" title="router-link详解"></a>router-link详解</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&#x27;&#x27;</span> <span class="attr">tag</span>=<span class="string">&#x27;&#x27;</span> <span class="attr">replace</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">to属性:指明路由到的地址</span></span><br><span class="line"><span class="comment">tag属性:指明router-link渲染为什么标签，默认为&lt;a&gt;</span></span><br><span class="line"><span class="comment">replace:有此属性表示为replace模式路由</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--被点击后，渲染后的标签会添加一个class--&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="手动router-link"><a href="#手动router-link" class="headerlink" title="手动router-link"></a>手动router-link</h4><p>通过监听点击事件，执行<code>this.$router.push(&#39;/home&#39;)</code>或者<code>this.$router.replace(&#39;/home&#39;)</code></p>
<p><strong>$router</strong>是vue默认添加的一个数据 </p>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>例：一个用户名为EE，userID：EE9696</p>
<p>我们要进入这个user的页面 即：<code>(/user/EE96966)</code>就需要动态路由</p>
<p>并且我们需要把此user 的ID：EE展示在其页面上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//router/index.js</span></span><br><span class="line">route:[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//动态绑定userid router-link的to会覆盖此属性</span></span><br><span class="line">        path:user/:userid </span><br><span class="line">        <span class="comment">//当然使用user.vue前需要import</span></span><br><span class="line">        component: user </span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--App.vue--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&#x27;finalID-path&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">        name:<span class="string">&#x27;App&#x27;</span>,</span></span><br><span class="line">        data()&#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="javascript">                name:EE    <span class="comment">//userName</span></span></span><br><span class="line"><span class="javascript">                ID:EE9696, <span class="comment">//需要的用户ID</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        computed:&#123;</span><br><span class="line"><span class="javascript">            <span class="comment">//得到finalID=/user/EE9696</span></span></span><br><span class="line">            finalID()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="string">&#x27;/user/&#x27;</span>+<span class="built_in">this</span>.ID</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="route与与展示ID"><a href="#route与与展示ID" class="headerlink" title="$route与与展示ID"></a>$route与与展示ID</h4><p><strong>$route</strong>拿到的是当前活跃的路由</p>
<p>​    注意与**$router<strong>区别:</strong>$router**拿到的是router对象</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--user.vue--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            ID:&#123;&#123;userID&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">        computed:&#123;</span><br><span class="line">            userID()&#123;</span><br><span class="line"><span class="javascript">                <span class="comment">//this.$route指当前活跃的路由</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">//params指参数</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">//userID是配置路由时route的动态path--:userID</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="built_in">this</span>.$route.params.userID</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>将所有业务代码打包到同一个js文件在网站加载时会非常慢</p>
<p>把不同路由对应的组件封装到不同的js中，这样在需要时再加载会提高效率，即路由的懒加载</p>
<p><strong>使用方法</strong></p>
<ul>
<li>传统的配置方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//router/index.js</span></span><br><span class="line"><span class="keyword">import</span> home <span class="keyword">from</span> <span class="string">&#x27;../component/home.vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123;</span><br><span class="line">        path:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">        component:<span class="string">&#x27;home&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>懒加载配置方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//router/index.js</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123;</span><br><span class="line">        path:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">        component:<span class="function">()=&gt;</span> <span class="keyword">import</span>(../component/home.vue)</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">//你也可以这样写</span></span><br><span class="line"><span class="keyword">const</span> home = <span class="function">() =&gt;</span> <span class="keyword">import</span>(../component/home.vue)</span><br><span class="line"><span class="keyword">const</span> routes =[</span><br><span class="line">    &#123;</span><br><span class="line">        path:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">        component<span class="string">&quot; home</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure>

<h2 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h2><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p>要在<code>/home</code>页面下设置<code>/home/news</code>和<code>/home/message</code></p>
<h3 id="配置和使用"><a href="#配置和使用" class="headerlink" title="配置和使用"></a>配置和使用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//router/index.js</span></span><br><span class="line"><span class="comment">//使用前引入，安装(省)</span></span><br><span class="line"><span class="keyword">const</span> routes:[</span><br><span class="line">    &#123;</span><br><span class="line">        path:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">        component:home,</span><br><span class="line">        children:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//嵌套的子组件路径前不加/</span></span><br><span class="line">                path:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">                component:news,</span><br><span class="line">            &#125;，</span><br><span class="line">            &#123;</span><br><span class="line">            	path:<span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">            	component:news</span><br><span class="line">			&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>因为我们是在home页面下配置的嵌套子路由，所以我们要在home.vue下配置<code>router-link</code>和<code>router-view</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--home.vue--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注意这里to必须是完整的路径，因为to不会切换到当前路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&#x27;/home/news&#x27;</span>&gt;</span>News<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&#x27;/home/message&#x27;</span>&gt;</span>Message<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>PS:嵌套路由也可以默认重定向</strong></p>
<h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><h3 id="params"><a href="#params" class="headerlink" title="params"></a>params</h3><ul>
<li>路径配置格式:  <code>path: &#39;/router/:id&#39;</code>=&gt;形成的路径格式<code>/router/id(变值)</code></li>
<li>获取：直接通过<code>&#123;&#123;$route.params.id(与path中的命名一致)&#125;&#125;</code>获取</li>
</ul>
<h3 id="query"><a href="#query" class="headerlink" title="query"></a>query</h3><ul>
<li><p>路由配置格式：普通格式</p>
</li>
<li><p>router-link配置：这时的<code>to=&#39;&#39;</code>里是一个对象</p>
<ul>
<li>对象内容：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	path:&#39;&#39;&#x2F;&#x2F;路由的路径</span><br><span class="line">	query:&#123;</span><br><span class="line">	&#x2F;&#x2F;这里是传入的数据</span><br><span class="line">		data: value</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取：在相应的组件中通过<code>&#123;&#123;$route.query.**&#125;&#125;</code>获得</p>
<ul>
<li>$route会自动传入data中，所以可以直接获取</li>
</ul>
</li>
</ul>
<h3 id="router-amp-route详解"><a href="#router-amp-route详解" class="headerlink" title="$router &amp; $route详解"></a>$router &amp; $route详解</h3><h2 id="全局导航守卫"><a href="#全局导航守卫" class="headerlink" title="全局导航守卫"></a>全局导航守卫</h2><p>​    用于监听路由跳转的过程。</p>
<h3 id="beforeEach"><a href="#beforeEach" class="headerlink" title="beforeEach"></a>beforeEach</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//router/index.js</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">//这里必须调用next()函数，用于跳转到下一个守卫</span></span><br><span class="line">	next()</span><br><span class="line">    <span class="comment">//这里的CODE会在跳转前执行</span></span><br><span class="line">    CODE</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="afterEach"><a href="#afterEach" class="headerlink" title="afterEach"></a>afterEach</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//router/index.js</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to.<span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//这里的CODE会在跳转后执行</span></span><br><span class="line">    CODE</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="路由独享守卫"><a href="#路由独享守卫" class="headerlink" title="路由独享守卫"></a>路由独享守卫</h2><h2 id="组件内守卫"><a href="#组件内守卫" class="headerlink" title="组件内守卫"></a>组件内守卫</h2><h2 id="vue-keepalive"><a href="#vue-keepalive" class="headerlink" title="vue-keepalive"></a>vue-keepalive</h2><p>vue组件的状态在跳转后不会被保存，每次会创建一个新的组件。这样不仅消耗资源，并且会带来一些使用上的问题</p>
<p>我们使用vue内置组件<code>&lt;keep-alive&gt;</code>来解决</p>
<ul>
<li>用法</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&#x27;&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>include和exclude参数<ul>
<li><code>include:&#39;&#39;</code>：仅’’内的组件套用<code>keep-alive</code></li>
<li><code>exclude:&#39;&#39;</code>：’’外的组件套用<code>keep-alive</code></li>
<li><code>&#39;&#39;</code>内为正则表达式或字符串</li>
</ul>
</li>
</ul>
<h3 id="activated-amp-deactivated"><a href="#activated-amp-deactivated" class="headerlink" title="activated()&amp;deactivated"></a>activated()&amp;deactivated</h3><p>​    在当前组件活跃(不活跃)时执行的函数</p>
<p>必须在<code>&lt;keep-alive&gt;</code>内包含的组件才能使用这两个函数</p>
<h1 id="TabBar实例"><a href="#TabBar实例" class="headerlink" title="TabBar实例"></a>TabBar实例</h1><ul>
<li>**SampleString.indexOf(String)**方法</li>
</ul>
<p>返回括号内<code>String</code>在<code>SampleString</code>第一次出现的位置，若没有出现则返回-1</p>
<h1 id="ES6-Promise"><a href="#ES6-Promise" class="headerlink" title="ES6 Promise"></a>ES6 Promise</h1><p><strong>Promise</strong> 用于封装异步操作</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Promise使用时需要new，并且传入一个带resolve, reject两个参数的函数</span></span><br><span class="line"><span class="comment">//而resolve和reject也是两个函数</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//成功时调用resolve函数会跳转到当前Promise的then处执行函数func</span></span><br><span class="line">    <span class="comment">//data = ajax(url)</span></span><br><span class="line">    resolve(data)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//失败是调用reject函数会跳转到当前Promise的catch处</span></span><br><span class="line">    reject(err)</span><br><span class="line">&#125;).then( <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">   	<span class="comment">//这里的data就是resolve()传入的data</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//这里的err就是reject传入的err</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>若需要嵌套调用异步操作，则需要在<code>then</code>或者<code>catch</code>中返回一个新的<code>Promise</code>对象</p>
<h2 id="Promise的三种状态"><a href="#Promise的三种状态" class="headerlink" title="Promise的三种状态"></a>Promise的三种状态</h2><p><img src="https://img-blog.csdnimg.cn/20191101143126460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDAxMzgxNw==,size_16,color_FFFFFF,t_70" alt="PromiseStatus"></p>
<h1 id="VUEX（待办）"><a href="#VUEX（待办）" class="headerlink" title="VUEX（待办）"></a>VUEX（待办）</h1><h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure>

<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> axios</span><br></pre></td></tr></table></figure>

<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul>
<li>基本使用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">	url:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    params:&#123;&#125;</span><br><span class="line">    method:<span class="string">&#x27;&#x27;</span> <span class="comment">//get OR post</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>method</strong>省略后也可以简写</p>
<p>​    例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.post(&#123;</span><br><span class="line">	url:<span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="axios-all-发送并发请求"><a href="#axios-all-发送并发请求" class="headerlink" title="axios.all()发送并发请求"></a>axios.all()发送并发请求</h3><p><strong>场景：</strong>需要发送两个请求，并且两个请求均返回时再进行处理</p>
<p>可以使用</p>
<p><code>axios.all()</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.all(</span><br><span class="line">    [axios(&#123;</span><br><span class="line">        url:<span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">     axios(&#123;</span><br><span class="line">         url:<span class="string">&#x27;&#x27;</span></span><br><span class="line">     &#125;)</span><br><span class="line">]).then(<span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//注意这里的response是一个数组，带有两个请求返回的结果</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="axios的两个常用配置"><a href="#axios的两个常用配置" class="headerlink" title="axios的两个常用配置"></a>axios的两个常用配置</h2><h3 id="axios-defaults-baseURL"><a href="#axios-defaults-baseURL" class="headerlink" title="axios.defaults.baseURL"></a>axios.defaults.baseURL</h3><p><strong>场景：</strong>需要向’<a href="http://sample.com&/#39;%E4%B8%8B%E9%A2%91%E7%B9%81%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82">http://sample.com&#39;下频繁发送请求</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.defaults.baseURL = <span class="string">&#x27;http://sample.com&#x27;</span></span><br><span class="line"></span><br><span class="line">axios.get(&#123;</span><br><span class="line">    url:<span class="string">&#x27;/home&#x27;</span><span class="comment">//现在自动在前面添加baseURL</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="axios-defaults-timout"><a href="#axios-defaults-timout" class="headerlink" title="axios.defaults.timout"></a>axios.defaults.timout</h3><p>设置超时</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里设置请求时间超过5000ms为超时</span></span><br><span class="line">axios.defaults.timout = <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<h2 id="axios实例"><a href="#axios实例" class="headerlink" title="axios实例"></a>axios实例</h2><p>之前设置的axios配置是全局配置，若需要向不同的服务器发送请求，那么全局配置就不适用了，这就需要axios实例</p>
<ul>
<li>创建实例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> axiosSample = axios.create(&#123;</span><br><span class="line">	baseURL = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	timeout = <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用实例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用方法与原型一模一样</span></span><br><span class="line">axiosSample.get(&#123;</span><br><span class="line">	url:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	params:&#123;</span><br><span class="line">		type:</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="axios封装"><a href="#axios封装" class="headerlink" title="axios封装"></a>axios封装</h2><p>设想一下，你的每个程序都是用axios框架发送网络请求，但是某一天axios突然挂掉。那么需要重构的代码量将会非常巨大，为了应对这种情况，我们对框架做一层封装。</p>
<h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><ul>
<li>封装</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建立一个request.js文件作为axios封装的文件夹</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config, success, failure</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//创建axios实例</span></span><br><span class="line">    <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">        baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">        timeout: <span class="number">5000</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    instance(config)</span><br><span class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123; success(res) &#125;) <span class="comment">//成功时调用success</span></span><br><span class="line">        .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123; failure(err) &#125;)<span class="comment">//失败时调用failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用</p>
<p> 现在我们可以使用我们封装好的request函数</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">&#x27;../network/request.js&#x27;</span></span><br><span class="line"><span class="comment">//通过bitcorn提供的api打印bitcorn实时价格</span></span><br><span class="line">request(&#123;</span><br><span class="line">                   url:<span class="string">&#x27;https://api.coindesk.com/v1/bpi/currentprice.json&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line">res =&gt;&#123;</span><br><span class="line">    <span class="built_in">this</span>.info = res.data.bpi</span><br><span class="line">&#125;,</span><br><span class="line">err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="更好的封装方式"><a href="#更好的封装方式" class="headerlink" title="更好的封装方式"></a>更好的封装方式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">            baseURL: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            timeout: <span class="number">5000</span></span><br><span class="line">        &#125;)</span><br><span class="line">        instance(config)</span><br><span class="line">            .then(<span class="function"><span class="params">res</span> =&gt;</span> resolve(res))</span><br><span class="line">            .catch(<span class="function"><span class="params">err</span> =&gt;</span> reject(err))</span><br><span class="line">    &#125;)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此一来我们可以这样使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">&#x27;../network/request.js&#x27;</span></span><br><span class="line"></span><br><span class="line">request(&#123;</span><br><span class="line">	url:<span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">	.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;)</span><br><span class="line">	.catch(err=?&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>实际上axios返回的就是一个Promise对象，所以我们完全不用自建Promise</strong></p>
<ul>
<li>最终的封装方式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">            baseURL: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            timeout: <span class="number">5000</span></span><br><span class="line">        &#125;)</span><br><span class="line">       <span class="keyword">return</span> instance(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="axios拦截器"><a href="#axios拦截器" class="headerlink" title="axios拦截器"></a>axios拦截器</h2><p>为上面的封装添加拦截器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">            baseURL: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            timeout: <span class="number">5000</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//请求拦截器</span></span><br><span class="line">        instance.interceptors.request.use(</span><br><span class="line">            req=&gt;&#123;</span><br><span class="line">            <span class="comment">//请求发送成功时的操作，并且拦截到了请求</span></span><br><span class="line">            <span class="comment">//添加一条return req才能继续请求，要不然请求被拦截</span></span><br><span class="line">                <span class="keyword">return</span> req</span><br><span class="line">        	&#125;,</span><br><span class="line">            err=&gt;&#123;</span><br><span class="line">            <span class="comment">//请求发送失败时的操作</span></span><br><span class="line">        	&#125;</span><br><span class="line">        );</span><br><span class="line">    	<span class="comment">//响应拦截器</span></span><br><span class="line">    	instance.interceptors.response.use(</span><br><span class="line">        	res=&gt;&#123;</span><br><span class="line">                <span class="comment">//在这里对拦截到的响应作操作</span></span><br><span class="line">                <span class="comment">//同样需要return</span></span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            &#125;,</span><br><span class="line">            err=&gt;&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">//发送请求</span></span><br><span class="line">       <span class="keyword">return</span> instance(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>buliding...</tag>
      </tags>
  </entry>
</search>
